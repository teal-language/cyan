# Api Documentation
This documentation is autogenerated and may be incomplete

## `cyan.colorstring`
---

Some wrappers/conveniences around working with ansi escape codes For example getting the length of a string that contains escape codes shouldnt include them

#### `ColorString:surround(col: {number})`
surrounds a string with a color

#### `ColorString:tostring(): string`
Converts a `Colorstring` to a regular string with the correct ANSI escapes

#### `colorstring.highlight(hl: {number}, str: string): ColorString`
Create a `Colorstring` by surrounding a string with the given ANSI color and an ANSI reset

#### `colorstring.new(...: string | {number}): ColorString`
The `Colorstring` constructor

#### `colorstring.rgb_bg(r: number, g: number, b: number): {number, number, number, number, number}`
The ansi escape for an arbitrary RGB background color

#### `colorstring.rgb_fg(r: number, g: number, b: number): {number, number, number, number, number}`
The ansi escape for an arbitrary RGB foreground color

#### `record ColorString`
```lua
metamethod __len: function(ColorString): number
metamethod __concat: function(ColorString | string, ColorString | string): ColorString
content: {string | {number}}
len: function(ColorString): number
tostring: function(ColorString): string
```
The main object that this library consumes and produces. It basically implements the 'string' interface and can be used wherever a string is.

Colors are described as arrays of numbers that directly correspond to ANSI escape sequences

## `cyan.command`
---

The common interface for commands to implement

#### `command.get(name: string): Command`
Get a command that was created with `command.new`

Works whether or not `command.register_all` was called

#### `command.merge_args_into_config(cfg: config.Config, args: Args)`
Merge the relevant entries of the provided command arguments into the provided config table

#### `command.new(cmd: Command)`
Create a new command

This is stored in an internal cache and will do nothing unless `command.register_all` is called afterwards

#### `command.register_all(p: argparse.Parser)`
Install all commands created with `command.new` into the given parser

#### `record Command`
```lua

name: string
description: string
argparse: function(argparse.Command)
script_hooks: {string}
exec: CommandFn
```
The interface

## `cyan.config`
---

Config loading API

#### `config.find(): fs.Path`
Find `config.filename` in the current or parent directories

#### `config.is_config(c: any): Config, {string}, {string}`
Check if `c` conforms to the `Config` type and return any errors and warnings generated from checking

#### `config.load(): Config, {string}, {string}`
Try to load `tlconfig.lua` in the current directory

#### `record Config`
```lua

loaded_from: fs.Path
build_dir: string
source_dir: string
include: {string}
exclude: {string}
global_env_def: string
include_dir: {string}
module_name: string
scripts: {string:{string}}
gen_compat: tl.CompatMode
gen_target: tl.TargetMode
disable_warnings: {tl.WarningKind}
warning_error: {tl.WarningKind}
externals: {string:any}
```
The config data

## `cyan.fs.path`
---

Object oriented path management

#### `Path.eq(a: Path | string, b: Path | string, use_os_sep: boolean): boolean`
Check if two paths are equal

This function is used for the __eq metamethod with use_os_sep as false

#### `Path:ancestors(): function(): Path`
Iterate over the leading folders in a path

ex: `path.new("foo/bar/baz/bat"):ancestors()` will construct `Path` objects from "foo", "foo/bar", "foo/bar/baz"

#### `Path:append(other: string | Path)`
Mutate the given `Path` by appending another path to it

#### `Path:copy(): Path`
Create a copy of the given path

#### `Path:exists(): boolean`
Check if the path exists

#### `Path:is_absolute(): boolean`
Returns whether the path is absolute

On windows, checks for paths like "C:\...", elsewhere looks for "/..."

#### `Path:is_directory(): boolean`
Get whether the "mode" attribute of the given path is set to "directory"

#### `Path:is_file(): boolean`
Get whether the "mode" attribute of the given path is set to "file"

#### `Path:is_in(dirname: string | Path): boolean`
returns true if the path is inside the given directory

If relative and absolute paths are mixed, the relative path is assumed to be in the current working directory (as determined by `lfs.currentdir()`)

#### `Path:match(patt: string): boolean`
See if the given path matches the pattern

Path separators in patterns are always represented with '/'.

`*` characters represent any number of non-path-separator characters

`**/` represent any number of directories

#### `Path:match_any(patts: {string}): integer, string`
See if the given path matches any of the given patterns

#### `Path:mk_parent_dirs(): boolean, string`
Attempt to create the leading directories of a given path

#### `Path:mkdir(): boolean, string`
Attempt to create a directory at the given path, creating the parent directories if needed. Can be seen as an equivalent to `mkdir -p`

#### `Path:mod_time(): integer`
Get the "modification" attribute of a file

#### `Path:prepend(other: string | Path)`
Mutate the given `Path` by prepending another path to it

#### `Path:relative_to(other: Path): string`
Expresses a path in terms of another path. If any relative paths are given, they are treated as though they are in the current directory

Returns an actual path since path objects cannot contain '..'

for example: `path.new("/foo/bar/baz"):relative_to(path.new("/foo/bat")) == "../bar/baz"`

#### `Path:remove_leading(p: string | Path)`
Mutate the given path by removing the leading parts from the given path

Will error if you attempt to mix absolute and non-absolute paths

#### `Path:to_real_path(): string`
Convert a `Path` to a string describing a real path

#### `Path:tostring(): string`
Convert a path to a string. Always uses '/' as a path separator. Intended for displaying purposes. For an actual path in the filesystem, use `Path:to_real_path()`

Used for the __tostring metamethod

#### `path.ensure(s: string | Path): Path`
Ensures `s` is a Path

#### `path.new(s: string, use_os_sep: boolean): Path`
The `Path` constructor

By default uses '/' as a path separator

#### `record Path`
```lua
metamethod __concat: function(Path | string, Path | string): Path
metamethod __eq: function(Path | string, Path | string): boolean
{string}
```
The main path object. Basically just an array of strings with some methods and metamethods to interact with other paths

## `cyan.fs`
---

Search for a file in the parent directories of the given path. Returns the path of the file found.

e.g. if `file.txt` is in `/foo/bar` `fs.search_parent_dirs("/foo/bar/baz", "file.txt") == "/foo/bar/file.txt"`

#### `fs.chdir(p: string | Path): boolean, string`
Change the current directory to `p`

#### `fs.cwd(): Path`
Get the current working directory as an `fs.Path`

#### `fs.dir(dir: string | Path, include_dotfiles: boolean): function(): Path`
Iterate over the given directory, returning `fs.Path` objects

By default, will not include paths that start with '.'

#### `fs.scan_dir(dir: string | Path, include: {string}, exclude: {string}): function(): Path`
Recursively iterate over the files in a directory, following the provided `include` and `exclude` patterns

## `cyan.graph`
---

A utility for building directed acyclic graphs of Teal source files

This is the main driver behind the `build` command

#### `Dag:find(fstr: string | fs.Path): Node`
Find a node in the graph with the given path name

#### `Dag:insert_file(fstr: string | fs.Path, in_dir: string | fs.Path)`
Inserts a file and its dependencies into a graph

Ignores absolute paths and non `.tl` files

If in_dir is provided, dependencies of the given file will not be added to the graph unless they are inside of the given dir

#### `Dag:mark_each(predicate: function(fs.Path): boolean)`
For each node in the graph, if `predicate` returns true for that input path, the node is marked for compilation, and that node's children are marked for type checking

#### `Dag:marked_nodes(m: Node.Mark): function(): Node`
Iterate over every node with the given mark `m`. Iterates in order of most dependents to least

#### `Dag:nodes(): function(): Node`
Iterate over nodes in order of dependents

If two nodes have the same number of dependent nodes, the order of iteration between those two nodes is not guaranteed

#### `graph.empty(): Dag`
Initializes an empty graph

#### `graph.scan_dir(dir: string | fs.Path, include: {string}, exclude: {string}): Dag`
Recursively scan a directory (using `fs.scan_dir`) and build up a graph, respecting the given `include` and `exclude` patterns

#### `record Dag`
```lua


```
The graph object

## `cyan.log`
---

Console logging utils, not to be confused with log files

Each logging function has the same signature of `function(...: any)`, and by default the following are provided: `info` (stdout): General info, should be seen as the default, silenced by --quiet `warn` (stderr): Used to display warnings, silenced by --quiet `err` (stderr): Used to display errors `debug` (stderr): Used for debugging, uses the inspect module (if it is found) to print its arguments

You may notice that these are nicely padded and after the first line the prefix is replaced by a '...' Another function is provided, `create_logger`, ``` create_logger( stream: FILE, prefix: string | ColorString, cont: string | ColorString, inspector: function(any): string ): function(...: any) ``` to automatically generate formatted output. `cont` defaults to `"..."` and `inspector` defaults to `tostring`. Prefixes will be padded to 10 characters wide, so your logging may look off from the default if your prefix is longer.

#### `create_logger(
   stream: FILE,
   prefix: string | cs.ColorString,
   cont: string | cs.ColorString,
   inspector: function(any): string
): function(...: any)`
Creates a logging function as described above

## `cyan.script`
---

The script loading api

#### `script.disable()`
Make everything in this library a no-op, there is currently no way to re-enable this

#### `script.emit_hook(name: string, ...: any): boolean, string`
Iterates through each loaded script and runs any with the given hook, logging each script that it ran, and stopping early if any error

#### `script.emitter(name: string, ...: any): function(): fs.Path, boolean, string`
Emit a hook to run all loaded scripts that run on the given hook. Returns an iterator that will run the next script when called and returns the path to the script, whether the script succeeded, and an error message if it didn't

#### `script.load(path: string, flags: {string}): boolean, string`
Loads a file as a lua/teal script and caches it with the given flags to be run when `script.emit_hook` is called

This is called by the cli driver to load the scripts found in the config file with the relevant hooks

## `cyan.tlcommon`
---

Common things needed by most commands in addition to wrappers around the tl api, since it isn't super stable

#### `common.init_env_from_config(cfg: config.Config): tl.Env, string`
Initialize a strict Teal environment, using the relevant entries of the config to modify that environment

may return `nil` and an error message if something could not be applied to the environment

#### `common.init_teal_env(gen_compat: boolean | tl.CompatMode, gen_target: tl.TargetMode, env_def: string): tl.Env, string`
Initialize a strict Teal environment

#### `common.make_error_header(file: string, num_errors: number, category: string): string`
Creates a nicely colored header to log errors

For example `make_error_header("foo.tl", 10, "foo error")` would produce something like `10 foo errors in foo.tl` with `10` and `foo.tl` highlighted

#### `common.prepend_to_lua_path(path_str: string)`
Prepend the given string to package.path and package.cpath.

Correctly adds ?.lua and ?/init.lua to the path

#### `common.report_config_errors(errs: {string}, warnings: {string}): boolean`
use `log.warn` and `log.err` to report errors and warnings from `config.load`

#### `common.report_env_results(env: tl.Env, cfg: config.Config): boolean`
Report all errors from a tl.Env

Returns false when errors were reported

#### `common.report_errors(logfn: function(...: any), errs: {tl.Error}, file: string, category: string)`
Logs an array of errors with nice colors and a header generated by `make_error_header`

#### `common.report_result(r: tl.Result, c: config.Config): boolean`
Logs all the syntax errors, warnings, type errors, etc. from a `tl.Result` with proper colors

Returns if there were any warnings or unknowns. May return `true` even if some warnings were reported

#### `common.result_has_errors(r: tl.Result, c: config.Config): boolean`
Returns whether or not the result has errors. Doesn't print/log anything

#### `common.search_module(name: string, search_dtl: boolean): fs.Path`
A wrapper around `tl.search_module` but, returns an `fs.Path` and will cache results

#### `common.type_check_ast(ast: Node, opts: tl.TypeCheckOptions): tl.Result`
Just type checks an ast

#### `record ParseResult`
```lua

tks: {Token}
ast: Node
reqs: {string}
errs: {tl.Error}
```
The result from parsing source code including the tokens, ast, calls to require, and errors

## `cyan.util`
---

Basically some extensions of the std lib Currently these lean towards a more functional style

#### `str.esc(s: string, sub: string | function(string): string | {string:string}): string, number`
escape any special characters in a string

use `sub` to control how the characters are substituted, by default a special character `x` will be replaced with `%x`

#### `str.pad_left(s: string, n: number): string`
Prefix `s` with spaces so the resulting string is at least `n` characters long

#### `str.split(s: string, del: string, no_patt: boolean): function(): string`
Split a string by `del`, returning the substring that was matched

Will error if the delimiter matches the empty string

#### `str.split_find(s: string, del: string, no_patt: boolean): function(): number, number`
Split a string by `del`, returning the indexes of the match

Will error if the delimiter matches the empty string

#### `tab.filter(t: {T}, pred: function(T): boolean): {T}, {T}`
Create two new lists from `t`: the values that return `true` from `pred` and the values that return false

#### `tab.from(fn: function(...: any): (T), ...: any): {T}`
Collect all the values of an iterator in a list

#### `tab.ivalues(t: {any:V}): function(): V`
Iterate over the integer indexed values of a map

#### `tab.keys(t: {K:any}): function(): K`
Iterate over the keys of a map

#### `tab.map(t: {K:V}, fn: function(V): T): {K:T}`
Create a new map from `t` by passing each value through `fn`

#### `tab.map_ipairs(t: {T}, fn: function(T): K): function(): number, K`
iterate over a list like ipairs does, but filter the values through `fn`

#### `tab.merge_list(a: {T}, b: {T}): {T}`
Create a new list by shallow copying the contents of `a` and `b`

#### `tab.set(lst: {T}): {T:boolean}`
Create a Set from a list

#### `tab.sort(t: {T}, fn: function(T, T): boolean): {T}`
Sort a table (in place) and return that table

#### `tab.values(t: {K:V}): function(): V`
Iterate over the values of a map

