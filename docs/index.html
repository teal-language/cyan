<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8"/>
<style>
/*
* {
	border: 1px solid magenta !important;
}
*/

html {
	background-color: #16191a;
}

body {
	background-color: #18191c;
	margin: 2em auto;
	width: 80%;
	max-width: 80%;
	padding: 32px;
	font-family: Helvetica, Arial, sans-serif;
	color: #e8e6e3;
	border: solid #afafcf 1px;
	border-radius: 2em;
}

a {
	color: #3391ff;
	text-decoration: none;
	padding: 3px 3px 3px 3px;
}

a:link:hover {
	color: #7095ff;
	background-color: #25282A;
	border-radius: 4px;
}

h2::before {
	content: "\2756";
	padding-right: 0.5em;
}

h1, h2, h3, h4, h5, h6 {
	color: #117dee;
	font-family: Verdana, Geneva, sans-serif;
}

p, pre, table {
	padding-left: 2%;
}

.description {
	margin: 0 0 5% 5%;
}

.keyword {
	color: #799ae0;
}

.string {
	color: #d16161;
}

.signature {
	width: 80%;
	background-color: #202330;
	border: solid #afafcf 1px;
	border-radius: 6px;
	padding: 5px;
}

.bulleted:before {
	content: "\2022 ";
}

.module-name:before { content: "\2756 "; }
.module-name { font-weight: bold; }
.private-field-comment {
	color: #77405F;
	font-weight: bold;
}

.parameter-name {
}

.parameter-type {
	color: #C7B1F2;
}

</style>

<body>
<h1>Cyan API Documentation</h1>
<p>
This documentation is auto-generated and may be incomplete.
</p>

<h1>Table of Contents</h1>

<table width='100%'><tbody><td valign=top>
<p><a class=module-name href=#cyan.cli>cyan.cli</a>
<br></p>
<p><a class=module-name href=#cyan.command>cyan.command</a>
<br><a href=#Command>Command</a>
<br><a href=#command.get>command.get</a>
<br><a href=#command.merge_args_into_config>command.merge_args_into_config</a>
<br><a href=#command.new>command.new</a>
<br><a href=#command.register_all>command.register_all</a>
</p>
<p><a class=module-name href=#cyan.config>cyan.config</a>
<br><a href=#Config>Config</a>
<br><a href=#config.find>config.find</a>
<br><a href=#config.is_config>config.is_config</a>
<br><a href=#config.load>config.load</a>
</p>
</td><td valign=top><p><a class=module-name href=#cyan.decoration>cyan.decoration</a>
<br><a href=#Color>Color</a>
<br><a href=#Decorated:copy>Decorated:copy</a>
<br><a href=#Decorated>Decorated</a>
<br><a href=#Decoration>Decoration</a>
<br><a href=#Renderer>Renderer</a>
<br><a href=#SchemeEntry>SchemeEntry</a>
<br><a href=#decoration.color_copy>decoration.color_copy</a>
<br><a href=#decoration.copy>decoration.copy</a>
<br><a href=#decoration.decorate>decoration.decorate</a>
<br><a href=#decoration.file_name>decoration.file_name</a>
<br><a href=#decoration.render_ansi>decoration.render_ansi</a>
<br><a href=#decoration.render_plain>decoration.render_plain</a>
<br><a href=#decoration.render_to_string>decoration.render_to_string</a>
<br><a href=#decoration.rgb>decoration.rgb</a>
</p>
<p><a class=module-name href=#cyan.fs>cyan.fs</a>
<br><a href=#fs.change_directory>fs.change_directory</a>
<br><a href=#fs.copy>fs.copy</a>
<br><a href=#fs.current_directory>fs.current_directory</a>
<br><a href=#fs.exists>fs.exists</a>
<br><a href=#fs.get_line>fs.get_line</a>
<br><a href=#fs.is_directory>fs.is_directory</a>
<br><a href=#fs.is_file>fs.is_file</a>
<br><a href=#fs.iterate_directory>fs.iterate_directory</a>
<br><a href=#fs.make_directory>fs.make_directory</a>
<br><a href=#fs.make_parent_directories>fs.make_parent_directories</a>
<br><a href=#fs.match_any>fs.match_any</a>
<br><a href=#fs.mod_time>fs.mod_time</a>
<br><a href=#fs.normalize>fs.normalize</a>
<br><a href=#fs.read>fs.read</a>
<br><a href=#fs.scan_directory>fs.scan_directory</a>
<br><a href=#fs.search_parent_dirs>fs.search_parent_dirs</a>
</p>
<p><a class=module-name href=#cyan.graph>cyan.graph</a>
<br><a href=#Dag:find>Dag:find</a>
<br><a href=#Dag:insert_file>Dag:insert_file</a>
<br><a href=#Dag:mark_each>Dag:mark_each</a>
<br><a href=#Dag:marked_nodes>Dag:marked_nodes</a>
<br><a href=#Dag:nodes>Dag:nodes</a>
<br><a href=#Dag>Dag</a>
<br><a href=#Node>Node</a>
<br><a href=#graph.empty>graph.empty</a>
<br><a href=#graph.scan_directory>graph.scan_directory</a>
</p>
<p><a class=module-name href=#cyan.interaction>cyan.interaction</a>
<br><a href=#interaction.yes_no_prompt>interaction.yes_no_prompt</a>
</p>
<p><a class=module-name href=#cyan.log>cyan.log</a>
<br><a href=#ColorMode>ColorMode</a>
<br><a href=#Logger:cont>Logger:cont</a>
<br><a href=#Logger:cont_nonl>Logger:cont_nonl</a>
<br><a href=#Logger:copy>Logger:copy</a>
<br><a href=#Logger:format>Logger:format</a>
<br><a href=#Logger:format_nonl>Logger:format_nonl</a>
<br><a href=#Logger:nonl>Logger:nonl</a>
<br><a href=#Logger:should_log>Logger:should_log</a>
<br><a href=#Logger>Logger</a>
<br><a href=#Verbosity>Verbosity</a>
<br><a href=#create_logger>create_logger</a>
<br><a href=#log.set_color_mode>log.set_color_mode</a>
<br><a href=#log.set_prefix_padding>log.set_prefix_padding</a>
<br><a href=#log.set_verbosity>log.set_verbosity</a>
</p>
</td><td valign=top><p><a class=module-name href=#cyan.meta>cyan.meta</a>
<br></p>
<p><a class=module-name href=#cyan.sandbox>cyan.sandbox</a>
<br></p>
<p><a class=module-name href=#cyan.script>cyan.script</a>
<br><a href=#script.disable>script.disable</a>
<br><a href=#script.emit_hook>script.emit_hook</a>
<br><a href=#script.emitter>script.emitter</a>
<br><a href=#script.ensure_loaded_for_command>script.ensure_loaded_for_command</a>
<br><a href=#script.register>script.register</a>
</p>
<p><a class=module-name href=#cyan.tlcommon>cyan.tlcommon</a>
<br><a href=#ParseResult>ParseResult</a>
<br><a href=#common.init_env_from_config>common.init_env_from_config</a>
<br><a href=#common.init_teal_env>common.init_teal_env</a>
<br><a href=#common.lex_file>common.lex_file</a>
<br><a href=#common.make_error_header>common.make_error_header</a>
<br><a href=#common.parse_file>common.parse_file</a>
<br><a href=#common.prepend_to_lua_path>common.prepend_to_lua_path</a>
<br><a href=#common.report_config_errors>common.report_config_errors</a>
<br><a href=#common.report_env_results>common.report_env_results</a>
<br><a href=#common.report_errors>common.report_errors</a>
<br><a href=#common.report_result>common.report_result</a>
<br><a href=#common.result_has_errors>common.result_has_errors</a>
<br><a href=#common.search_module>common.search_module</a>
<br><a href=#common.syntax_highlight>common.syntax_highlight</a>
</p>
<p><a class=module-name href=#cyan.util>cyan.util</a>
<br><a href=#peek>peek</a>
<br><a href=#str.esc>str.esc</a>
<br><a href=#str.pad_left>str.pad_left</a>
<br><a href=#str.split>str.split</a>
<br><a href=#str.split_find>str.split_find</a>
<br><a href=#tab.contains>tab.contains</a>
<br><a href=#tab.ensure_scalar_array>tab.ensure_scalar_array</a>
<br><a href=#tab.filter>tab.filter</a>
<br><a href=#tab.from>tab.from</a>
<br><a href=#tab.intersperse>tab.intersperse</a>
<br><a href=#tab.ivalues>tab.ivalues</a>
<br><a href=#tab.keys>tab.keys</a>
<br><a href=#tab.map>tab.map</a>
<br><a href=#tab.map_ipairs>tab.map_ipairs</a>
<br><a href=#tab.merge_list>tab.merge_list</a>
<br><a href=#tab.set>tab.set</a>
<br><a href=#tab.sort_in_place>tab.sort_in_place</a>
<br><a href=#tab.values>tab.values</a>
</p>
</td>
</td></tbody></table>

<h2><a name=cyan.cli>cyan.cli</a>
</h2>
<p><p>The command line driver</p><p>This is not a module to be used and requiring it will attempt to start the cli and call os.exit</p></p>
<h2><a name=cyan.command>cyan.command</a>
</h2>
<p><p>The common interface for commands to implement</p></p>
<h3><a name=Command><code class=bulleted>type Command</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>record</code> Command
	name: <code class=parameter-type>string</code>
	description: <code class=parameter-type>string</code>
	argparse: <code class=parameter-type>function(argparse.Command)</code>
	script_hooks: <code class=parameter-type>{string}</code>
	exec: <code class=parameter-type>CommandFn</code>
<code class=keyword>end</code></code></pre><p><p>The interface</p></p>
</div><h3><a name=command.get><code class=bulleted>function command.get</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> command.get(
	<code class=parameter-name>name</code>: <code class=parameter-type>string</code>
): <code class=parameter-type>Command</code></code></pre><p><p>Get a command that was created with <code>command.new</code></p><p>Works whether or not <code>command.register_all</code> was called</p></p>
</div><h3><a name=command.merge_args_into_config><code class=bulleted>function command.merge_args_into_config</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> command.merge_args_into_config(
	<code class=parameter-name>cfg</code>: <code class=parameter-type>config.Config</code>,
	<code class=parameter-name>args</code>: <code class=parameter-type>Args</code>
)</code></pre><p><p>Merge the relevant entries of the provided command arguments into the provided config table</p></p>
</div><h3><a name=command.new><code class=bulleted>function command.new</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> command.new(
	<code class=parameter-name>cmd</code>: <code class=parameter-type>Command</code>
)</code></pre><p><p>Create a new command</p><p>This is stored in an internal cache and will do nothing unless <code>command.register_all</code> is called afterwards</p></p>
</div><h3><a name=command.register_all><code class=bulleted>function command.register_all</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> command.register_all(
	<code class=parameter-name>p</code>: <code class=parameter-type>argparse.Parser</code>
)</code></pre><p><p>Install all commands created with <code>command.new</code> into the given parser</p></p>
</div><h2><a name=cyan.config>cyan.config</a>
</h2>
<p><p>Config loading API</p></p>
<h3><a name=Config><code class=bulleted>type Config</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>record</code> Config
	loaded_from: <code class=parameter-type>lexical_path.Path</code>
	build_dir: <code class=parameter-type>lexical_path.Path</code>
	source_dir: <code class=parameter-type>lexical_path.Path</code>
	include: <code class=parameter-type>{lexical_path.Pattern}</code>
	exclude: <code class=parameter-type>{lexical_path.Pattern}</code>
	global_env_def: <code class=parameter-type>string</code>
	include_dir: <code class=parameter-type>{lexical_path.Path}</code>
	dont_prune: <code class=parameter-type>{string}</code>
	scripts: <code class=parameter-type>{string:{string:{lexical_path.Path}}}</code>
	feat_arity: <code class=parameter-type>tl.Feat</code>
	gen_compat: <code class=parameter-type>tl.GenCompat</code>
	gen_target: <code class=parameter-type>tl.GenTarget</code>
	disable_warnings: <code class=parameter-type>{tl.WarningKind}</code>
	warning_error: <code class=parameter-type>{tl.WarningKind}</code>
	externals: <code class=parameter-type>{string:any}</code>
<code class=keyword>end</code></code></pre><p><p>The config data</p></p>
</div><h3><a name=config.find><code class=bulleted>function config.find</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> config.find(): <code class=parameter-type>lexical_path.Path</code></code></pre><p><p>Find <code>config.filename</code> in the current or parent directories</p></p>
</div><h3><a name=config.is_config><code class=bulleted>function config.is_config</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> config.is_config(
	<code class=parameter-name>c_in</code>: <code class=parameter-type>any</code>
): <code class=parameter-type>Config</code>, <code class=parameter-type>{string}</code>, <code class=parameter-type>{string}</code></code></pre><p><p>Check if <code>c</code> conforms to the <code>Config</code> type and return any errors and warnings generated from checking</p></p>
</div><h3><a name=config.load><code class=bulleted>function config.load</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> config.load(): <code class=parameter-type>Config</code>, <code class=parameter-type>{string}</code>, <code class=parameter-type>{string}</code></code></pre><p><p>Try to load <code>tlconfig.lua</code> in the current directory</p></p>
</div><h2><a name=cyan.decoration>cyan.decoration</a>
</h2>
<p><p>A replacement for colorstring that doesn't specifically rely on ANSI terminal escapes</p></p>
<h3><a name=Color><code class=bulleted>type Color</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>record</code> Color
	red: <code class=parameter-type>integer</code>
	green: <code class=parameter-type>integer</code>
	blue: <code class=parameter-type>integer</code>
<code class=keyword>end</code></code></pre><p><p>A color described by rgb values in [0, 255]</p></p>
</div><h3><a name=Decorated:copy><code class=bulleted>method Decorated:copy</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> Decorated:copy(
	<code class=parameter-name>delta</code>: <code class=parameter-type>Decoration</code>
): <code class=parameter-type>Decorated</code></code></pre><p><p>Deeply copy the decoration of a decorated string</p></p>
</div><h3><a name=Decorated><code class=bulleted>type Decorated</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>record</code> Decorated
	plain_content: <code class=parameter-type>string</code>
	decoration: <code class=parameter-type>Decoration</code>
<code class=keyword>end</code></code></pre><p><p>A string and a decoration</p></p>
</div><h3><a name=Decoration><code class=bulleted>type Decoration</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>record</code> Decoration
	bold: <code class=parameter-type>boolean</code>
	italic: <code class=parameter-type>boolean</code>
	monospace: <code class=parameter-type>boolean</code>
	linked_uri: <code class=parameter-type>string</code>
	color: <code class=parameter-type>Color</code>
	background_color: <code class=parameter-type>Color</code>
	ansi_color: <code class=parameter-type>integer</code>
	ansi_background_color: <code class=parameter-type>integer</code>
<code class=keyword>end</code></code></pre><p><p>Various visual properties that could apply to some text</p></p>
</div><h3><a name=Renderer><code class=bulleted>type Renderer</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>type</code> Renderer<code class=parameter-type>function(out_buffer: {string}, plain_content: string, Decoration)</code></code></pre><p><p>Render the decorated contents into <code>out_buffer</code></p><p><code>Renderer</code>s are assumed to be stateless, and results may be cached and rearranged in the actual output</p></p>
</div><h3><a name=SchemeEntry><code class=bulleted>type SchemeEntry</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>enum</code> SchemeEntry
	<code class=string>"black"</code>
	<code class=string>"red"</code>
	<code class=string>"green"</code>
	<code class=string>"yellow"</code>
	<code class=string>"blue"</code>
	<code class=string>"magenta"</code>
	<code class=string>"cyan"</code>
	<code class=string>"white"</code>
	<code class=string>"gray"</code>
	<code class=string>"bright_red"</code>
	<code class=string>"bright_green"</code>
	<code class=string>"bright_yellow"</code>
	<code class=string>"bright_blue"</code>
	<code class=string>"bright_magenta"</code>
	<code class=string>"bright_cyan"</code>
	<code class=string>"bright_white"</code>
	<code class=string>"teal"</code>
	<code class=string>"emphasis"</code>
	<code class=string>"error"</code>
	<code class=string>"error_number"</code>
	<code class=string>"file"</code>
	<code class=string>"keyword"</code>
	<code class=string>"number"</code>
	<code class=string>"operator"</code>
	<code class=string>"string"</code>
	<code class=string>"warn"</code>
	<code class=string>"affirmative"</code>
	<code class=string>"negative"</code>
<code class=keyword>end</code></code></pre><p><p>Predefined decorations used for logging, syntax highlighting errors, etc.</p></p>
</div><h3><a name=decoration.color_copy><code class=bulleted>function decoration.color_copy</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> decoration.color_copy(
	<code class=parameter-name>c</code>: <code class=parameter-type>Color</code>
): <code class=parameter-type>Color</code></code></pre><p><p>Deep copy a <code>Color</code></p></p>
</div><h3><a name=decoration.copy><code class=bulleted>function decoration.copy</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> decoration.copy(
	<code class=parameter-name>to_be_copied</code>: <code class=parameter-type>Decoration</code>,
	<code class=parameter-name>delta</code>: <code class=parameter-type>Decoration</code>
): <code class=parameter-type>Decoration</code></code></pre><p><p>Deep copy a <code>Decoration</code>, but copy values from <code>delta</code> when present</p></p>
</div><h3><a name=decoration.decorate><code class=bulleted>function decoration.decorate</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> decoration.decorate(
	<code class=parameter-name>plain</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>decor</code>: <code class=parameter-type>Decoration</code>
): <code class=parameter-type>Decorated</code></code></pre><p><p>Create a decorated string</p></p>
</div><h3><a name=decoration.file_name><code class=bulleted>function decoration.file_name</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> decoration.file_name(
	<code class=parameter-name>path</code>: <code class=parameter-type>string | lexical_path.Path</code>
): <code class=parameter-type>Decorated</code></code></pre><p><p>Decorate using the default decoration for file names and a uri for the path</p></p>
</div><h3><a name=decoration.render_ansi><code class=bulleted>function decoration.render_ansi</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> decoration.render_ansi(
	<code class=parameter-name>buf</code>: <code class=parameter-type>{string}</code>,
	<code class=parameter-name>content</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>decor</code>: <code class=parameter-type>Decoration</code>
)</code></pre><p><p>Render decorations as ANSI escape sequences</p></p>
</div><h3><a name=decoration.render_plain><code class=bulleted>function decoration.render_plain</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> decoration.render_plain(
	<code class=parameter-name>buf</code>: <code class=parameter-type>{string}</code>,
	<code class=parameter-name>content</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>_decoration</code>: <code class=parameter-type>Decoration</code>
)</code></pre><p><p>Render text by discarding all decorations</p></p>
</div><h3><a name=decoration.render_to_string><code class=bulleted>function decoration.render_to_string</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> decoration.render_to_string(
	<code class=parameter-name>render</code>: <code class=parameter-type>Renderer</code>,
	<code class=parameter-name>plain_content</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>decor</code>: <code class=parameter-type>Decoration</code>
): <code class=parameter-type>string</code></code></pre><p><p>A convenience function to render to a buffer, then concatenate that buffer</p></p>
</div><h3><a name=decoration.rgb><code class=bulleted>function decoration.rgb</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> decoration.rgb(
	<code class=parameter-name>red</code>: <code class=parameter-type>integer</code>,
	<code class=parameter-name>green</code>: <code class=parameter-type>integer</code>,
	<code class=parameter-name>blue</code>: <code class=parameter-type>integer</code>
): <code class=parameter-type>Color</code></code></pre><p><p>Positional constructor for <code>Color</code></p></p>
</div><h2><a name=cyan.fs>cyan.fs</a>
</h2>
<p><p>Filesystem and path management</p></p>
<h3><a name=fs.change_directory><code class=bulleted>function fs.change_directory</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> fs.change_directory(
	<code class=parameter-name>p</code>: <code class=parameter-type>lexical_path.Path</code>
): <code class=parameter-type>boolean</code>, <code class=parameter-type>string</code></code></pre><p><p>Attempt to change the current directory to the directory referred to by the given path. On success returns true. On failure returns nil and an error message.</p></p>
</div><h3><a name=fs.copy><code class=bulleted>function fs.copy</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> fs.copy(
	<code class=parameter-name>source_path</code>: <code class=parameter-type>lexical_path.Path</code>,
	<code class=parameter-name>dest_path</code>: <code class=parameter-type>lexical_path.Path</code>
): <code class=parameter-type>boolean</code>, <code class=parameter-type>string</code></code></pre><p><p>Copy a file</p><p>uses <code>fs.read</code> internally to get and cache the contents of <code>source</code></p></p>
</div><h3><a name=fs.current_directory><code class=bulleted>function fs.current_directory</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> fs.current_directory(): <code class=parameter-type>lexical_path.Path</code>, <code class=parameter-type>string</code></code></pre><p><p>On success returns the current working directory as a lexical path. On error returns nil and an error message</p></p>
</div><h3><a name=fs.exists><code class=bulleted>function fs.exists</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> fs.exists(
	<code class=parameter-name>p</code>: <code class=parameter-type>lexical_path.Path</code>
): <code class=parameter-type>boolean</code></code></pre><p><p>Attempt to see if the path referred to by <code>p</code> exists.</p></p>
</div><h3><a name=fs.get_line><code class=bulleted>function fs.get_line</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> fs.get_line(
	<code class=parameter-name>p</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>n</code>: <code class=parameter-type>integer</code>
): <code class=parameter-type>string</code>, <code class=parameter-type>string</code></code></pre><p><p>Gets line <code>n</code> of a file.</p><p>if the file is less than <code>n</code> lines, returns <code>nil</code></p><p>if there was an error opening the file, returns <code>nil</code>, err</p><p>Uses <code>fs.read()</code> internally, which caches reads</p></p>
</div><h3><a name=fs.is_directory><code class=bulleted>function fs.is_directory</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> fs.is_directory(
	<code class=parameter-name>p</code>: <code class=parameter-type>lexical_path.Path</code>
): <code class=parameter-type>boolean</code>, <code class=parameter-type>string</code></code></pre><p><p>Return if the file referred to by the given path is a directory.</p><p>On failure, returns nil and an error message</p></p>
</div><h3><a name=fs.is_file><code class=bulleted>function fs.is_file</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> fs.is_file(
	<code class=parameter-name>p</code>: <code class=parameter-type>lexical_path.Path</code>
): <code class=parameter-type>boolean</code>, <code class=parameter-type>string</code></code></pre><p><p>Return if the file referred to by the given path is a regular file</p></p>
</div><h3><a name=fs.iterate_directory><code class=bulleted>function fs.iterate_directory</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> fs.iterate_directory(
	<code class=parameter-name>dir</code>: <code class=parameter-type>lexical_path.Path</code>,
	<code class=parameter-name>include_dotfiles</code>: <code class=parameter-type>boolean</code>
): <code class=parameter-type>function(): lexical_path.Path</code></code></pre><p><p>Iterate over the given directory, returning <code>fs.Path</code> objects</p><p>By default, will not include paths that start with <code>'.'</code></p></p>
</div><h3><a name=fs.make_directory><code class=bulleted>function fs.make_directory</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> fs.make_directory(
	<code class=parameter-name>path</code>: <code class=parameter-type>lexical_path.Path</code>
): <code class=parameter-type>boolean</code>, <code class=parameter-type>string</code></code></pre><p><p>Create a directory with the given path, creating any ancestor directories</p><p>In unixy terms, this is <code>mkdir -p</code></p></p>
</div><h3><a name=fs.make_parent_directories><code class=bulleted>function fs.make_parent_directories</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> fs.make_parent_directories(
	<code class=parameter-name>of</code>: <code class=parameter-type>lexical_path.Path</code>
): <code class=parameter-type>boolean</code>, <code class=parameter-type>string</code></code></pre><p><p>For each ancestor of the given path, <code>mkdir</code> that path</p><p>In unixy terms, this is roughly <code>mkdir -p path/..</code></p></p>
</div><h3><a name=fs.match_any><code class=bulleted>function fs.match_any</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> fs.match_any(
	<code class=parameter-name>path</code>: <code class=parameter-type>lexical_path.Path</code>,
	<code class=parameter-name>patterns</code>: <code class=parameter-type>{string | lexical_path.Pattern}</code>
): <code class=parameter-type>integer</code></code></pre><p><p>If the given path matches any of the patterns in <code>patterns</code>, returns the index of the matched pattern otherwise returns <code>nil</code></p></p>
</div><h3><a name=fs.mod_time><code class=bulleted>function fs.mod_time</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> fs.mod_time(
	<code class=parameter-name>of</code>: <code class=parameter-type>lexical_path.Path</code>
): <code class=parameter-type>integer</code>, <code class=parameter-type>string</code></code></pre><p><p>Returns the modification time of the file referred to by the given path</p><p>In case of an error, returns nil, and an error message</p></p>
</div><h3><a name=fs.normalize><code class=bulleted>function fs.normalize</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> fs.normalize(
	<code class=parameter-name>p</code>: <code class=parameter-type>string</code>
): <code class=parameter-type>string</code></code></pre><p><p>Normalizes a given path via the <code>lexical_path</code> library</p></p>
</div><h3><a name=fs.read><code class=bulleted>function fs.read</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> fs.read(
	<code class=parameter-name>p</code>: <code class=parameter-type>string</code>
): <code class=parameter-type>string</code>, <code class=parameter-type>string</code></code></pre><p><p>Open a file, read it, close the file, return the contents or <code>nil</code> and an error if it couldn't be opened</p><p>Additionally caches results so multiple locations can read the same file for minimal cost. There is currently no way to clear out this cache.</p></p>
</div><h3><a name=fs.scan_directory><code class=bulleted>function fs.scan_directory</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> fs.scan_directory(
	<code class=parameter-name>dir</code>: <code class=parameter-type>lexical_path.Path</code>,
	<code class=parameter-name>include</code>: <code class=parameter-type>{string | lexical_path.Pattern}</code>,
	<code class=parameter-name>exclude</code>: <code class=parameter-type>{string | lexical_path.Pattern}</code>,
	<code class=parameter-name>include_directories</code>: <code class=parameter-type>boolean</code>
): <code class=parameter-type>function(): lexical_path.Path</code></code></pre><p><p>Recursively iterate over the files in a directory, following the provided <code>include</code> and <code>exclude</code> patterns</p><p>For information on path patterns, see the <code>Path:match()</code> method</p></p>
</div><h3><a name=fs.search_parent_dirs><code class=bulleted>function fs.search_parent_dirs</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> fs.search_parent_dirs(
	<code class=parameter-name>start_path</code>: <code class=parameter-type>lexical_path.Path</code>,
	<code class=parameter-name>fname</code>: <code class=parameter-type>string</code>
): <code class=parameter-type>lexical_path.Path</code></code></pre><p><p>Search for a file in the parent directories of the given path. Returns the path of the file found.</p><p>e.g. if <code>file.txt</code> is in <code>/foo/bar</code>, then <code>fs.search_parent_dirs(<code>"/foo/bar/baz"</code>, <code>"file.txt"</code>) == path.new <code>"/foo/bar/file.txt"</code></code></p></p>
</div><h2><a name=cyan.graph>cyan.graph</a>
</h2>
<p><p>A utility for building directed acyclic graphs of Teal source files</p><p>This is the main driver behind the <code>build</code> command</p></p>
<h3><a name=Dag:find><code class=bulleted>method Dag:find</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> Dag:find(
	<code class=parameter-name>f</code>: <code class=parameter-type>lexical_path.Path</code>
): <code class=parameter-type>Node</code></code></pre><p><p>Find a node in the graph with the given path name</p></p>
</div><h3><a name=Dag:insert_file><code class=bulleted>method Dag:insert_file</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> Dag:insert_file(
	<code class=parameter-name>f</code>: <code class=parameter-type>lexical_path.Path</code>,
	<code class=parameter-name>in_dir</code>: <code class=parameter-type>lexical_path.Path</code>
): <code class=parameter-type>boolean</code>, <code class=parameter-type>{string}</code></code></pre><p><p>Inserts a file and its dependencies into a graph</p><p>Ignores absolute paths and non <code>.tl</code> or <code>.lua</code> files</p><p>If in_dir is provided, dependencies of the given file will not be added to the graph unless they are inside of the given dir</p><p>Returns <code>false</code> if inserting the file introduced a circular dependency along with a list of the filenames in the cycle</p></p>
</div><h3><a name=Dag:mark_each><code class=bulleted>method Dag:mark_each</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> Dag:mark_each(
	<code class=parameter-name>predicate</code>: <code class=parameter-type>function(lexical_path.Path): boolean</code>
)</code></pre><p><p>For each node in the graph, if <code>predicate</code> returns true for that input path, the node is marked for compilation, and that node's children are marked for type checking</p></p>
</div><h3><a name=Dag:marked_nodes><code class=bulleted>method Dag:marked_nodes</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> Dag:marked_nodes(): <code class=parameter-type>function(): Node</code></code></pre><p><p>Iterate over every node that has been marked, no matter what the mark is</p></p>
</div><h3><a name=Dag:nodes><code class=bulleted>method Dag:nodes</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> Dag:nodes(): <code class=parameter-type>function(): Node</code></code></pre><p><p>Iterate over nodes in order of dependents</p><p>If two nodes have the same number of dependent nodes, they are sorted by input filename lexicographically</p></p>
</div><h3><a name=Dag><code class=bulleted>type Dag</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>record</code> Dag
<details><summary class="private-field-comment">	-- private fields (click to show)</summary>
	_nodes_by_filename: <code class=parameter-type>{string:Node}</code></details>
<code class=keyword>end</code></code></pre><p><p>The graph object</p></p>
</div><h3><a name=Node><code class=bulleted>type Node</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>record</code> Node
	input: <code class=parameter-type>lexical_path.Path</code>
	output: <code class=parameter-type>lexical_path.Path</code>
	modules: <code class=parameter-type>{string:lexical_path.Path}</code>
	mark: <code class=parameter-type>Mark</code>
	dependents: <code class=parameter-type>{Node:boolean}</code>
<code class=keyword>end</code></code></pre><p><p>The nodes that are stored in the graph</p></p>
</div><h3><a name=graph.empty><code class=bulleted>function graph.empty</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> graph.empty(): <code class=parameter-type>Dag</code></code></pre><p><p>Initializes an empty graph</p></p>
</div><h3><a name=graph.scan_directory><code class=bulleted>function graph.scan_directory</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> graph.scan_directory(
	<code class=parameter-name>dir</code>: <code class=parameter-type>lexical_path.Path</code>,
	<code class=parameter-name>include</code>: <code class=parameter-type>{string | lexical_path.Pattern}</code>,
	<code class=parameter-name>exclude</code>: <code class=parameter-type>{string | lexical_path.Pattern}</code>
): <code class=parameter-type>Dag</code>, <code class=parameter-type>{string}</code></code></pre><p><p>Recursively scan a directory (using <code>fs.scan_directory</code>) and build up a graph, respecting the given <code>include</code> and <code>exclude</code> patterns</p><p>Returns <code>nil</code> if a circular dependency was found, along with a list of the filenames in the cycle</p></p>
</div><h2><a name=cyan.interaction>cyan.interaction</a>
</h2>
<p><p>Module for handling when input from the user is needed</p></p>
<h3><a name=interaction.yes_no_prompt><code class=bulleted>function interaction.yes_no_prompt</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> interaction.yes_no_prompt(
	<code class=parameter-name>prompt</code>: <code class=parameter-type>string | decoration.Decorated</code>,
	<code class=parameter-name>logger</code>: <code class=parameter-type>log.Logger</code>,
	<code class=parameter-name>default</code>: <code class=parameter-type>boolean</code>,
	<code class=parameter-name>affirm</code>: <code class=parameter-type>{string}</code>,
	<code class=parameter-name>deny</code>: <code class=parameter-type>{string}</code>
): <code class=parameter-type>boolean</code></code></pre><p><p>Ask the user to affirm or deny a given prompt. The user input will be compared against the given <code>affirm</code> and <code>deny</code> lists (case-insensitive), with defaults used if they are not provided.</p><p>The given logger will be used to print the prompt, and <code>log.info</code> if none is provided.</p></p>
</div><h2><a name=cyan.log>cyan.log</a>
</h2>
<p><p>Console logging utils, not to be confused with log files</p><p>Each logger object has the same <code>__call</code> signature of <code>function(...: any)</code>, and by default the following are provided:</p><p></p><table> <tr><th> Name     </th><th> Stream </th><th> Description</th></tr> <tr><td>       <code>info</code>   </td><td> stdout </td><td> General info, should be seen as the default, silenced by --quiet</td></tr> <tr><td>       <code>extra</code>  </td><td> stdout </td><td> Extra info that isn&apos;t strictly necessary, enabled via -v extra, silenced by --quiet</td></tr> <tr><td>       <code>warn</code>   </td><td> stderr </td><td> Used to display warnings, silenced by --quiet</td></tr> <tr><td>       <code>err</code>    </td><td> stderr </td><td> Used to display errors</td></tr> <tr><td>       <code>debug</code>  </td><td> stderr </td><td> Used for debugging, uses the inspect module (if it is found) to print its arguments, enabled by -v debug</td></tr> </table><p></p><p>You may notice that these are nicely padded and after the first line the prefix is replaced by a <code>'...'</code>. Another function is provided, <code>create_logger</code>,</p><p></p><pre> create_logger: function(<br>    stream: FILE,<br>    verbosity_threshold: Verbosity,<br>    prefix: string | decoration.Decorated,<br>    cont: string | decoration.Decorated,<br>    inspector: function(any): string<br> ): Logger<br> </pre><p> to automatically generate formatted output. <code>cont</code> defaults to <code><code>"..."</code></code> and <code>inspector</code> defaults to <code>tostring</code>. Prefixes will be padded to 10 characters wide by default, so your logging may look off from the default if your prefix is longer.</p><p>Additionally, loggers will try to detect whether or not to display colors. This is only handled with the <code>decoration.Decorated</code> type to avoid the many pitfalls of trying to parse ANSI escape sequences. If a regular string contains any escape sequences or an inspector produces them (outside of a <code>decoration.Decorated</code>) it will not be handled.</p></p>
<h3><a name=ColorMode><code class=bulleted>type ColorMode</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>enum</code> ColorMode
	<code class=string>"always"</code>
	<code class=string>"never"</code>
	<code class=string>"auto"</code>
<code class=keyword>end</code></code></pre><p><p>Whether to apply color to the output</p></p>
</div><h3><a name=Logger:cont><code class=bulleted>method Logger:cont</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> Logger:cont(
	<code class=parameter-name>...</code>: <code class=parameter-type>any</code>
)</code></pre><p><p>Log only using the continuation prefix.</p></p>
</div><h3><a name=Logger:cont_nonl><code class=bulleted>method Logger:cont_nonl</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> Logger:cont_nonl(
	<code class=parameter-name>...</code>: <code class=parameter-type>any</code>
)</code></pre><p><p>Log only using the continuation prefix, but don't put a newline at the end.</p></p>
</div><h3><a name=Logger:copy><code class=bulleted>method Logger:copy</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> Logger:copy(
	<code class=parameter-name>new_prefix</code>: <code class=parameter-type>string | decoration.Decorated</code>,
	<code class=parameter-name>new_continuation</code>: <code class=parameter-type>string | decoration.Decorated</code>
): <code class=parameter-type>Logger</code></code></pre><p><p>Create a copy of a logger, deep copying relevant data</p></p>
</div><h3><a name=Logger:format><code class=bulleted>method Logger:format</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> Logger:format(
	<code class=parameter-name>fmt</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>...</code>: <code class=parameter-type>any</code>
)</code></pre><p><p>Call <code>string.format</code> with the given arguments and log that.</p></p>
</div><h3><a name=Logger:format_nonl><code class=bulleted>method Logger:format_nonl</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> Logger:format_nonl(
	<code class=parameter-name>fmt</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>...</code>: <code class=parameter-type>any</code>
)</code></pre><p><p>Call <code>string.format</code> with the given arguments and log that, without a new line.</p></p>
</div><h3><a name=Logger:nonl><code class=bulleted>method Logger:nonl</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> Logger:nonl(
	<code class=parameter-name>...</code>: <code class=parameter-type>any</code>
)</code></pre><p><p>Same as calling the logger, but don't put a newline at the end</p></p>
</div><h3><a name=Logger:should_log><code class=bulleted>method Logger:should_log</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> Logger:should_log(): <code class=parameter-type>boolean</code></code></pre><p><p>Returns whether the current verbosity is less than or equal to this loggers verbosity threshold.</p></p>
</div><h3><a name=Logger><code class=bulleted>type Logger</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>record</code> Logger
	stream: <code class=parameter-type>FILE</code>
	verbosity_threshold: <code class=parameter-type>Verbosity</code>
	prefix: <code class=parameter-type>string | decoration.Decorated</code>
	continuation: <code class=parameter-type>string | decoration.Decorated</code>
	inspector: <code class=parameter-type>function(any): string</code>

	<code class=keyword>metamethod</code> __call: <code class=parameter-type>function(...: any)</code>
<code class=keyword>end</code></code></pre><p><p>The data needed for a logger to do its job.</p></p>
</div><h3><a name=Verbosity><code class=bulleted>type Verbosity</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>enum</code> Verbosity
	<code class=string>"quiet"</code>
	<code class=string>"normal"</code>
	<code class=string>"extra"</code>
	<code class=string>"debug"</code>
<code class=keyword>end</code></code></pre><p><p>The thresholds for loggers to actually write their output</p></p>
</div><h3><a name=create_logger><code class=bulleted>function create_logger</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> create_logger(
	<code class=parameter-name>stream</code>: <code class=parameter-type>FILE</code>,
	<code class=parameter-name>verbosity_threshold</code>: <code class=parameter-type>Verbosity</code>,
	<code class=parameter-name>prefix</code>: <code class=parameter-type>string | decoration.Decorated</code>,
	<code class=parameter-name>cont</code>: <code class=parameter-type>string | decoration.Decorated</code>,
	<code class=parameter-name>inspector</code>: <code class=parameter-type>function(any): string</code>
): <code class=parameter-type>Logger</code></code></pre><p><p>Creates a Logger as described above</p></p>
</div><h3><a name=log.set_color_mode><code class=bulleted>function log.set_color_mode</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> log.set_color_mode(
	<code class=parameter-name>mode</code>: <code class=parameter-type>ColorMode</code>
)</code></pre><p><p>Globally set the color behavior of the logging module.</p></p>
</div><h3><a name=log.set_prefix_padding><code class=bulleted>function log.set_prefix_padding</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> log.set_prefix_padding(
	<code class=parameter-name>padding</code>: <code class=parameter-type>integer</code>
)</code></pre><p><p>Globally set the padding of the prefixes of loggers.</p></p>
</div><h3><a name=log.set_verbosity><code class=bulleted>function log.set_verbosity</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> log.set_verbosity(
	<code class=parameter-name>level</code>: <code class=parameter-type>Verbosity</code>
)</code></pre><p><p>Globally set the verbosity of the logging module.</p></p>
</div><h2><a name=cyan.meta>cyan.meta</a>
</h2>
<p><p>Meta information about Cyan itself</p></p>
<h2><a name=cyan.sandbox>cyan.sandbox</a>
</h2>
<p><p>Super simplistic sandboxing In the future maybe could be integrated with some very simple debugging utilities for now, we just offer the convenience of exiting gracefully if someone puts <code>while true do end</code> in their config for some reason</p></p>
<h2><a name=cyan.script>cyan.script</a>
</h2>
<p><p>The script loading api</p></p>
<h3><a name=script.disable><code class=bulleted>function script.disable</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> script.disable()</code></pre><p><p>Make everything in this library a no-op, there is currently no way to re-enable this</p></p>
</div><h3><a name=script.emit_hook><code class=bulleted>function script.emit_hook</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> script.emit_hook(
	<code class=parameter-name>name</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>...</code>: <code class=parameter-type>any</code>
): <code class=parameter-type>boolean</code>, <code class=parameter-type>string</code></code></pre><p><p>Iterates through each loaded script and runs any with the given hook, logging each script that it ran, and stopping early if any error</p></p>
</div><h3><a name=script.emitter><code class=bulleted>function script.emitter</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> script.emitter(
	<code class=parameter-name>name</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>...</code>: <code class=parameter-type>any</code>
): <code class=parameter-type>function(): lexical_path.Path, boolean, string</code></code></pre><p><p>Emit a hook to load and run all registered scripts that run on the given hook.</p><p>This function will assert that <code>ensure_loaded_for_command</code> was called before.</p><p>Returns an iterator that will run the next script when called and returns the path to the script, whether the script was loaded and ran with no errors, and an error message if it didn't</p></p>
</div><h3><a name=script.ensure_loaded_for_command><code class=bulleted>function script.ensure_loaded_for_command</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> script.ensure_loaded_for_command(
	<code class=parameter-name>name</code>: <code class=parameter-type>string</code>
): <code class=parameter-type>boolean</code>, <code class=parameter-type>string | tl.Result</code></code></pre><p><p>Attempts to load each script that the given command may need</p></p>
</div><h3><a name=script.register><code class=bulleted>function script.register</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> script.register(
	<code class=parameter-name>path</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>command_name</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>hooks</code>: <code class=parameter-type>string | {string}</code>
)</code></pre><p><p>Registers a file path as a lua/teal script to execute for the given hook(s) when <code>script.emit_hook</code> is called</p><p>This is called by the cli driver to register the scripts found in the config file with the relevant hooks</p><p>Note: this function does not attempt to actually load the file. Scripts are loaded all at once via <code>ensure_loaded_for_command</code></p></p>
</div><h2><a name=cyan.tlcommon>cyan.tlcommon</a>
</h2>
<p><p>Common things needed by most commands in addition to wrappers around the tl api, since it isn't super stable</p></p>
<h3><a name=ParseResult><code class=bulleted>type ParseResult</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>record</code> ParseResult
	tks: <code class=parameter-type>{tl.Token}</code>
	ast: <code class=parameter-type>tl.Node</code>
	reqs: <code class=parameter-type>{string}</code>
	errs: <code class=parameter-type>{tl.Error}</code>
<code class=keyword>end</code></code></pre><p><p>The result from parsing source code including the tokens, ast, calls to require, and errors</p></p>
</div><h3><a name=common.init_env_from_config><code class=bulleted>function common.init_env_from_config</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> common.init_env_from_config(
	<code class=parameter-name>cfg</code>: <code class=parameter-type>config.Config</code>
): <code class=parameter-type>tl.Env</code>, <code class=parameter-type>string</code></code></pre><p><p>Initialize a strict Teal environment, using the relevant entries of the config to modify that environment</p><p>may return <code>nil</code> and an error message if something could not be applied to the environment</p></p>
</div><h3><a name=common.init_teal_env><code class=bulleted>function common.init_teal_env</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> common.init_teal_env(
	<code class=parameter-name>gen_compat</code>: <code class=parameter-type>boolean | tl.GenCompat</code>,
	<code class=parameter-name>gen_target</code>: <code class=parameter-type>tl.GenTarget</code>,
	<code class=parameter-name>env_def</code>: <code class=parameter-type>string</code>
): <code class=parameter-type>tl.Env</code>, <code class=parameter-type>string</code></code></pre><p><p>Initialize a strict Teal environment</p></p>
</div><h3><a name=common.lex_file><code class=bulleted>function common.lex_file</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> common.lex_file(
	<code class=parameter-name>path</code>: <code class=parameter-type>string</code>
): <code class=parameter-type>{tl.Token}</code>, <code class=parameter-type>{tl.Error}</code>, <code class=parameter-type>string</code></code></pre><p><p>reads a file, calls <code>tl.lex</code> on its contents, caches and returns the results</p></p>
</div><h3><a name=common.make_error_header><code class=bulleted>function common.make_error_header</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> common.make_error_header(
	<code class=parameter-name>file</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>num_errors</code>: <code class=parameter-type>integer</code>,
	<code class=parameter-name>category</code>: <code class=parameter-type>string</code>
): <code class=parameter-type>{string | decoration.Decorated}</code></code></pre><p><p>Creates a nicely colored header to log errors</p><p>For example <code>make_error_header(<code>"foo.tl"</code>, 10, <code>"foo error"</code>)</code> would produce something like <code>10 foo errors in foo.tl</code> with <code>10</code> and <code>foo.tl</code> highlighted</p></p>
</div><h3><a name=common.parse_file><code class=bulleted>function common.parse_file</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> common.parse_file(
	<code class=parameter-name>path</code>: <code class=parameter-type>string</code>
): <code class=parameter-type>ParseResult</code>, <code class=parameter-type>string</code></code></pre><p><p>calls <code>lex_file</code>, parses the token stream, caches and returns the results</p></p>
</div><h3><a name=common.prepend_to_lua_path><code class=bulleted>function common.prepend_to_lua_path</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> common.prepend_to_lua_path(
	<code class=parameter-name>path_str</code>: <code class=parameter-type>string</code>
)</code></pre><p><p>Prepend the given string to package.path and package.cpath.</p><p>Correctly adds ?.lua and ?/init.lua to the path</p></p>
</div><h3><a name=common.report_config_errors><code class=bulleted>function common.report_config_errors</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> common.report_config_errors(
	<code class=parameter-name>errs</code>: <code class=parameter-type>{string}</code>,
	<code class=parameter-name>warnings</code>: <code class=parameter-type>{string}</code>
): <code class=parameter-type>boolean</code></code></pre><p><p>use <code>log.warn</code> and <code>log.err</code> to report errors and warnings from <code>config.load</code></p></p>
</div><h3><a name=common.report_env_results><code class=bulleted>function common.report_env_results</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> common.report_env_results(
	<code class=parameter-name>env</code>: <code class=parameter-type>tl.Env</code>,
	<code class=parameter-name>cfg</code>: <code class=parameter-type>config.Config</code>
): <code class=parameter-type>boolean</code></code></pre><p><p>Report all errors from a tl.Env</p><p>Returns false when errors were reported</p></p>
</div><h3><a name=common.report_errors><code class=bulleted>function common.report_errors</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> common.report_errors(
	<code class=parameter-name>logger</code>: <code class=parameter-type>log.Logger</code>,
	<code class=parameter-name>errs</code>: <code class=parameter-type>{tl.Error}</code>,
	<code class=parameter-name>file</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>category</code>: <code class=parameter-type>string</code>
)</code></pre><p><p>Logs an array of errors with nice colors and a header generated by <code>make_error_header</code></p></p>
</div><h3><a name=common.report_result><code class=bulleted>function common.report_result</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> common.report_result(
	<code class=parameter-name>r</code>: <code class=parameter-type>tl.Result</code>,
	<code class=parameter-name>c</code>: <code class=parameter-type>config.Config</code>
): <code class=parameter-type>boolean</code></code></pre><p><p>Logs all the syntax errors, warnings, type errors, etc. from a <code>tl.Result</code> with proper colors</p><p>Returns false if there were any errors. This includs warnings that were promoted to errors and doesn't include warnings that were not promoted to errors.</p></p>
</div><h3><a name=common.result_has_errors><code class=bulleted>function common.result_has_errors</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> common.result_has_errors(
	<code class=parameter-name>r</code>: <code class=parameter-type>tl.Result</code>,
	<code class=parameter-name>c</code>: <code class=parameter-type>config.Config</code>
): <code class=parameter-type>boolean</code></code></pre><p><p>Returns whether or not the result has errors. Doesn't print/log anything</p></p>
</div><h3><a name=common.search_module><code class=bulleted>function common.search_module</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> common.search_module(
	<code class=parameter-name>name</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>search_dtl</code>: <code class=parameter-type>boolean</code>
): <code class=parameter-type>lexical_path.Path</code></code></pre><p><p>A wrapper around <code>tl.search_module</code> but, returns an <code>lexical_path.Path</code> and will cache results</p></p>
</div><h3><a name=common.syntax_highlight><code class=bulleted>function common.syntax_highlight</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> common.syntax_highlight(
	<code class=parameter-name>s</code>: <code class=parameter-type>string</code>
): <code class=parameter-type>{decoration.Decorated}</code></code></pre><p><p>Takes Teal or Lua code and returns a decorated string highlighting things like keywords, operators, and more.</p></p>
</div><h2><a name=cyan.util>cyan.util</a>
</h2>
<p><p>Basically some extensions of the std lib. Currently these lean towards a more functional style</p><p>This is split into two main modules, <code>str</code> and <code>tab</code>. For string and table utilities respectively.</p></p>
<h3><a name=peek><code class=bulleted>function peek</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> peek&lt;<code class=parameter-type>Value</code>&gt;(
	<code class=parameter-name>iter</code>: <code class=parameter-type>function(...: any): (Value)</code>,
	<code class=parameter-name>...</code>: <code class=parameter-type>any</code>
): <code class=parameter-type>function(): Value</code>, <code class=parameter-type>Value</code></code></pre><p><p>Takes an iterator and turns it into an iterator that returns pairs of values</p><p>For example if some iterator <code>f</code> returns the sequence 1, 2, 3 <code>peek(f)</code> would return the pairs (1, 2), (2, 3), (3, nil)</p></p>
</div><h3><a name=str.esc><code class=bulleted>function str.esc</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> str.esc(
	<code class=parameter-name>s</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>sub</code>: <code class=parameter-type>string | function(string): string | {string:string}</code>
): <code class=parameter-type>string</code>, <code class=parameter-type>integer</code></code></pre><p><p>escape any special characters in a string</p><p>use <code>sub</code> to control how the characters are substituted, by default a special character <code>x</code> will be replaced with <code>%x</code></p><p>returns the new string and the number of characters replaced</p></p>
</div><h3><a name=str.pad_left><code class=bulleted>function str.pad_left</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> str.pad_left(
	<code class=parameter-name>s</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>n</code>: <code class=parameter-type>integer</code>
): <code class=parameter-type>string</code></code></pre><p><p>Prefix <code>s</code> with spaces so the resulting string is at least <code>n</code> characters long</p></p>
</div><h3><a name=str.split><code class=bulleted>function str.split</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> str.split(
	<code class=parameter-name>s</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>del</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>no_patt</code>: <code class=parameter-type>boolean</code>
): <code class=parameter-type>function(): string</code></code></pre><p><p>Split a string by <code>del</code>, returning the substring that was matched</p><p>Will error if the delimiter matches the empty string</p></p>
</div><h3><a name=str.split_find><code class=bulleted>function str.split_find</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> str.split_find(
	<code class=parameter-name>s</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>del</code>: <code class=parameter-type>string</code>,
	<code class=parameter-name>no_patt</code>: <code class=parameter-type>boolean</code>
): <code class=parameter-type>function(): integer</code>, <code class=parameter-type>integer</code></code></pre><p><p>Split a string by <code>del</code>, returning the indexes of the match</p><p>Will error if the delimiter matches the empty string</p></p>
</div><h3><a name=tab.contains><code class=bulleted>function tab.contains</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> tab.contains&lt;<code class=parameter-type>Value</code>&gt;(
	<code class=parameter-name>t</code>: <code class=parameter-type>{Value}</code>,
	<code class=parameter-name>val</code>: <code class=parameter-type>Value</code>
): <code class=parameter-type>boolean</code></code></pre><p><p>Report if an array contains an element (as determined by the <code>==</code> operator)</p></p>
</div><h3><a name=tab.ensure_scalar_array><code class=bulleted>function tab.ensure_scalar_array</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> tab.ensure_scalar_array&lt;<code class=parameter-type>Value</code>&gt;(
	<code class=parameter-name>source</code>: <code class=parameter-type>Value | {Value}</code>
): <code class=parameter-type>{Value}</code></code></pre><p><p>If <code>source</code> is not an array, create an array with <code>source</code> as its only element</p><p>Note: Due to teal's current generic limitations, this only works if <code>Value</code> is a NON-table type</p></p>
</div><h3><a name=tab.filter><code class=bulleted>function tab.filter</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> tab.filter&lt;<code class=parameter-type>Value</code>&gt;(
	<code class=parameter-name>t</code>: <code class=parameter-type>{Value}</code>,
	<code class=parameter-name>pred</code>: <code class=parameter-type>function(Value): boolean</code>
): <code class=parameter-type>{Value}</code>, <code class=parameter-type>{Value}</code></code></pre><p><p>Create two new lists from <code>t</code>: the values that return <code>true</code> from <code>pred</code> and the values that return false</p></p>
</div><h3><a name=tab.from><code class=bulleted>function tab.from</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> tab.from&lt;<code class=parameter-type>Value</code>&gt;(
	<code class=parameter-name>fn</code>: <code class=parameter-type>function(...: any): (Value)</code>,
	<code class=parameter-name>...</code>: <code class=parameter-type>any</code>
): <code class=parameter-type>{Value}</code></code></pre><p><p>Collect all the values of an iterator in a list</p></p>
</div><h3><a name=tab.intersperse><code class=bulleted>function tab.intersperse</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> tab.intersperse&lt;<code class=parameter-type>Value</code>&gt;(
	<code class=parameter-name>t</code>: <code class=parameter-type>{Value}</code>,
	<code class=parameter-name>val</code>: <code class=parameter-type>Value</code>
): <code class=parameter-type>{Value}</code></code></pre><p><p>produce a new list by inserting <code>val</code> after each element</p></p>
</div><h3><a name=tab.ivalues><code class=bulleted>function tab.ivalues</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> tab.ivalues&lt;<code class=parameter-type>Value</code>&gt;(
	<code class=parameter-name>t</code>: <code class=parameter-type>{any:Value}</code>
): <code class=parameter-type>function(): Value</code></code></pre><p><p>Iterate over the integer indexed values of a map</p></p>
</div><h3><a name=tab.keys><code class=bulleted>function tab.keys</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> tab.keys&lt;<code class=parameter-type>Key</code>&gt;(
	<code class=parameter-name>t</code>: <code class=parameter-type>{Key:any}</code>
): <code class=parameter-type>function(): Key</code></code></pre><p><p>Iterate over the keys of a map</p></p>
</div><h3><a name=tab.map><code class=bulleted>function tab.map</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> tab.map&lt;<code class=parameter-type>Key</code>, <code class=parameter-type>Value</code>, <code class=parameter-type>MappedValue</code>&gt;(
	<code class=parameter-name>t</code>: <code class=parameter-type>{Key:Value}</code>,
	<code class=parameter-name>fn</code>: <code class=parameter-type>function(Value): MappedValue</code>
): <code class=parameter-type>{Key:MappedValue}</code></code></pre><p><p>Create a new map from <code>t</code> by passing each value through <code>fn</code></p></p>
</div><h3><a name=tab.map_ipairs><code class=bulleted>function tab.map_ipairs</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> tab.map_ipairs&lt;<code class=parameter-type>Value</code>, <code class=parameter-type>MappedValue</code>&gt;(
	<code class=parameter-name>t</code>: <code class=parameter-type>{Value}</code>,
	<code class=parameter-name>fn</code>: <code class=parameter-type>function(Value): MappedValue</code>
): <code class=parameter-type>function(): integer</code>, <code class=parameter-type>MappedValue</code></code></pre><p><p>iterate over a list like ipairs does, but filter the values through <code>fn</code></p></p>
</div><h3><a name=tab.merge_list><code class=bulleted>function tab.merge_list</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> tab.merge_list&lt;<code class=parameter-type>Value</code>&gt;(
	<code class=parameter-name>a</code>: <code class=parameter-type>{Value}</code>,
	<code class=parameter-name>b</code>: <code class=parameter-type>{Value}</code>
): <code class=parameter-type>{Value}</code></code></pre><p><p>Create a new list by shallow copying the contents of <code>a</code> and <code>b</code></p></p>
</div><h3><a name=tab.set><code class=bulleted>function tab.set</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> tab.set&lt;<code class=parameter-type>Value</code>&gt;(
	<code class=parameter-name>lst</code>: <code class=parameter-type>{Value}</code>
): <code class=parameter-type>{Value:boolean}</code></code></pre><p><p>Create a Set from a list</p></p>
</div><h3><a name=tab.sort_in_place><code class=bulleted>function tab.sort_in_place</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> tab.sort_in_place&lt;<code class=parameter-type>Value</code>&gt;(
	<code class=parameter-name>t</code>: <code class=parameter-type>{Value}</code>,
	<code class=parameter-name>fn</code>: <code class=parameter-type>function(Value, Value): boolean</code>
): <code class=parameter-type>{Value}</code></code></pre><p><p>Sort a table (in place) and return that table</p></p>
</div><h3><a name=tab.values><code class=bulleted>function tab.values</code></a>
</h3>
<div class=description><pre class=signature><code><code class=keyword>function</code> tab.values&lt;<code class=parameter-type>Key</code>, <code class=parameter-type>Value</code>&gt;(
	<code class=parameter-name>t</code>: <code class=parameter-type>{Key:Value}</code>
): <code class=parameter-type>function(): Value</code></code></pre><p><p>Iterate over the values of a map</p></p>
</div>

</body>
</html>
