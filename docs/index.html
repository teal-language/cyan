<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8"/>
<style>
html {
	background-color: #16191a;
}

body {
	background-color: #18191c;
	margin: 2em auto;
	width: 80%;
	max-width: 80%;
	padding: 32px;
	font-family: Helvetica, Arial, sans-serif;
	color: #e8e6e3;
	border: solid #afafcf 1px;
	border-radius: 2em;
}

a {
	color: #3391ff;
	text-decoration: none;
	padding: 3px 3px 3px 3px;
}

a:link:hover {
	color: #7095ff;
	background-color: #25282A;
	border-radius: 4px;
}

h2::before {
	content: "\2756";
	padding-right: 0.5em;
}

h1, h2, h3, h4, h5, h6 {
	color: #117dee;
	font-family: Verdana, Geneva, sans-serif;
}

p, pre, table {
	padding-left: 2%;
}

.module-name:before { content: "\2756 "; }
.module-name { font-weight: bold; }
.private-field-comment {
	color: #b0c4f6;
	font-weight: bold;
}
</style>

<body>
<h1>Cyan API Documentation</h1>
<p>
This documentation is auto-generated and may be incomplete.
</p>

<h1>Table of Contents</h1>

<table width='100%'><tbody><td valign=top>
<p><a class=module-name href=#cyan.ansi>cyan.ansi</a>
<br></p>
<p><a class=module-name href=#cyan.cli>cyan.cli</a>
<br></p>
<p><a class=module-name href=#cyan.colorstring>cyan.colorstring</a>
<br><a href=#ColorString:len>ColorString:len</a>
<br><a href=#ColorString:surround>ColorString:surround</a>
<br><a href=#ColorString:to_raw>ColorString:to_raw</a>
<br><a href=#ColorString:tostring>ColorString:tostring</a>
<br><a href=#ColorString>ColorString</a>
<br><a href=#colorstring.highlight>colorstring.highlight</a>
<br><a href=#colorstring.new>colorstring.new</a>
<br><a href=#colorstring.rgb_bg>colorstring.rgb_bg</a>
<br><a href=#colorstring.rgb_fg>colorstring.rgb_fg</a>
</p>
<p><a class=module-name href=#cyan.command>cyan.command</a>
<br><a href=#Command>Command</a>
<br><a href=#command.get>command.get</a>
<br><a href=#command.merge_args_into_config>command.merge_args_into_config</a>
<br><a href=#command.new>command.new</a>
<br><a href=#command.register_all>command.register_all</a>
</p>
<p><a class=module-name href=#cyan.config>cyan.config</a>
<br><a href=#Config>Config</a>
<br><a href=#config.find>config.find</a>
<br><a href=#config.is_config>config.is_config</a>
<br><a href=#config.load>config.load</a>
</p>
<p><a class=module-name href=#cyan.fs.path>cyan.fs.path</a>
<br><a href=#Path.eq>Path.eq</a>
<br><a href=#Path:ancestors>Path:ancestors</a>
<br><a href=#Path:append>Path:append</a>
<br><a href=#Path:copy>Path:copy</a>
<br><a href=#Path:exists>Path:exists</a>
<br><a href=#Path:is_absolute>Path:is_absolute</a>
<br><a href=#Path:is_directory>Path:is_directory</a>
<br><a href=#Path:is_file>Path:is_file</a>
<br><a href=#Path:is_in>Path:is_in</a>
<br><a href=#Path:match>Path:match</a>
<br><a href=#Path:match_any>Path:match_any</a>
<br><a href=#Path:mk_parent_dirs>Path:mk_parent_dirs</a>
<br><a href=#Path:mkdir>Path:mkdir</a>
<br><a href=#Path:mod_time>Path:mod_time</a>
<br><a href=#Path:normalize>Path:normalize</a>
<br><a href=#Path:prepend>Path:prepend</a>
<br><a href=#Path:relative_to>Path:relative_to</a>
<br><a href=#Path:remove_leading>Path:remove_leading</a>
<br><a href=#Path:to_absolute>Path:to_absolute</a>
<br><a href=#Path:to_real_path>Path:to_real_path</a>
<br><a href=#Path:tostring>Path:tostring</a>
<br><a href=#Path>Path</a>
<br><a href=#path.ensure>path.ensure</a>
<br><a href=#path.new>path.new</a>
</p>
</td><td valign=top><p><a class=module-name href=#cyan.fs>cyan.fs</a>
<br><a href=#fs.chdir>fs.chdir</a>
<br><a href=#fs.copy>fs.copy</a>
<br><a href=#fs.cwd>fs.cwd</a>
<br><a href=#fs.dir>fs.dir</a>
<br><a href=#fs.extension_split>fs.extension_split</a>
<br><a href=#fs.get_line>fs.get_line</a>
<br><a href=#fs.path_concat>fs.path_concat</a>
<br><a href=#fs.read>fs.read</a>
<br><a href=#fs.scan_dir>fs.scan_dir</a>
<br><a href=#fs.search_parent_dirs>fs.search_parent_dirs</a>
</p>
<p><a class=module-name href=#cyan.graph>cyan.graph</a>
<br><a href=#Dag:find>Dag:find</a>
<br><a href=#Dag:insert_file>Dag:insert_file</a>
<br><a href=#Dag:mark_each>Dag:mark_each</a>
<br><a href=#Dag:marked_nodes>Dag:marked_nodes</a>
<br><a href=#Dag:nodes>Dag:nodes</a>
<br><a href=#Dag>Dag</a>
<br><a href=#Node>Node</a>
<br><a href=#graph.empty>graph.empty</a>
<br><a href=#graph.scan_dir>graph.scan_dir</a>
</p>
<p><a class=module-name href=#cyan.log>cyan.log</a>
<br><a href=#Logger:cont>Logger:cont</a>
<br><a href=#Logger:cont_nonl>Logger:cont_nonl</a>
<br><a href=#Logger:format>Logger:format</a>
<br><a href=#Logger:format_nonl>Logger:format_nonl</a>
<br><a href=#Logger:nonl>Logger:nonl</a>
<br><a href=#Logger:should_log>Logger:should_log</a>
<br><a href=#Logger>Logger</a>
<br><a href=#Verbosity>Verbosity</a>
<br><a href=#create_logger>create_logger</a>
<br><a href=#log.set_prefix_padding>log.set_prefix_padding</a>
<br><a href=#log.set_verbosity>log.set_verbosity</a>
</p>
<p><a class=module-name href=#cyan.meta>cyan.meta</a>
<br></p>
</td><td valign=top><p><a class=module-name href=#cyan.sandbox>cyan.sandbox</a>
<br></p>
<p><a class=module-name href=#cyan.script>cyan.script</a>
<br><a href=#script.disable>script.disable</a>
<br><a href=#script.emit_hook>script.emit_hook</a>
<br><a href=#script.emitter>script.emitter</a>
<br><a href=#script.ensure_loaded_for_command>script.ensure_loaded_for_command</a>
<br><a href=#script.register>script.register</a>
</p>
<p><a class=module-name href=#cyan.tlcommon>cyan.tlcommon</a>
<br><a href=#ParseResult>ParseResult</a>
<br><a href=#common.init_env_from_config>common.init_env_from_config</a>
<br><a href=#common.init_teal_env>common.init_teal_env</a>
<br><a href=#common.lex_file>common.lex_file</a>
<br><a href=#common.make_error_header>common.make_error_header</a>
<br><a href=#common.parse_file>common.parse_file</a>
<br><a href=#common.prepend_to_lua_path>common.prepend_to_lua_path</a>
<br><a href=#common.report_config_errors>common.report_config_errors</a>
<br><a href=#common.report_env_results>common.report_env_results</a>
<br><a href=#common.report_errors>common.report_errors</a>
<br><a href=#common.report_result>common.report_result</a>
<br><a href=#common.result_has_errors>common.result_has_errors</a>
<br><a href=#common.search_module>common.search_module</a>
<br><a href=#common.type_check_ast>common.type_check_ast</a>
</p>
<p><a class=module-name href=#cyan.util>cyan.util</a>
<br><a href=#str.esc>str.esc</a>
<br><a href=#str.pad_left>str.pad_left</a>
<br><a href=#str.split>str.split</a>
<br><a href=#str.split_find>str.split_find</a>
<br><a href=#tab.contains>tab.contains</a>
<br><a href=#tab.filter>tab.filter</a>
<br><a href=#tab.from>tab.from</a>
<br><a href=#tab.intersperse>tab.intersperse</a>
<br><a href=#tab.ivalues>tab.ivalues</a>
<br><a href=#tab.keys>tab.keys</a>
<br><a href=#tab.map>tab.map</a>
<br><a href=#tab.map_ipairs>tab.map_ipairs</a>
<br><a href=#tab.merge_list>tab.merge_list</a>
<br><a href=#tab.set>tab.set</a>
<br><a href=#tab.sort_in_place>tab.sort_in_place</a>
<br><a href=#tab.values>tab.values</a>
</p>
</td>
</td></tbody></table>

<h2><a name=cyan.ansi>cyan.ansi</a>
</h2>
<p><p>A small utility library for grabbing the ANSI escapes for colors and such</p></p>
<h2><a name=cyan.cli>cyan.cli</a>
</h2>
<p><p>The command line driver</p><p>This is not a module to be used and requiring it will attempt to start the cli and call os.exit</p></p>
<h2><a name=cyan.colorstring>cyan.colorstring</a>
</h2>
<p><p>Some wrappers/conveniences around working with ansi escape codes. For example getting the length of a string that contains escape codes shouldnt include them</p></p>
<h3><a name=ColorString:len><code>ColorString:len(): integer</code></a>
</h3>
<p><p>Get the length of a given <code>ColorString</code>, not counting any escape sequences.</p><p>Note that <code>ColorString:len() >= ColorString:tostring():len()</code></p></p>
<h3><a name=ColorString:surround><code>ColorString:surround(col: {integer})</code></a>
</h3>
<p><p>surrounds a string with a color</p></p>
<h3><a name=ColorString:to_raw><code>ColorString:to_raw(): string</code></a>
</h3>
<p><p>Converts a <code>Colorstring</code> to a regular string, stripping any ANSI escapes</p></p>
<h3><a name=ColorString:tostring><code>ColorString:tostring(): string</code></a>
</h3>
<p><p>Converts a <code>Colorstring</code> to a regular string with the correct ANSI escapes</p></p>
<h3><a name=ColorString><code>type ColorString</code></a>
</h3>
<pre>record ColorString<br>   content: {string | {integer}}<br>   len: function(ColorString): integer<br>   tostring: function(ColorString): string<br><br>   metamethod __len: function(ColorString): integer<br>   metamethod __concat: function(ColorString | string, ColorString | string): ColorString<br>end</pre>
<p><p>The main object that this library consumes and produces. It basically implements the <code>'string'</code> interface and can be used wherever a string is.</p><p>Colors are described as arrays of numbers that directly correspond to ANSI escape sequences</p></p>
<h3><a name=colorstring.highlight><code>colorstring.highlight(hl: {integer}, str: string): ColorString</code></a>
</h3>
<p><p>Create a <code>Colorstring</code> by surrounding a string with the given ANSI color and an ANSI reset</p></p>
<h3><a name=colorstring.new><code>colorstring.new(...: string | {integer}): ColorString</code></a>
</h3>
<p><p>The <code>Colorstring</code> constructor</p></p>
<h3><a name=colorstring.rgb_bg><code>colorstring.rgb_bg(r: integer, g: integer, b: integer): {integer, integer, integer, integer, integer}</code></a>
</h3>
<p><p>The ansi escape for an arbitrary RGB background color</p></p>
<h3><a name=colorstring.rgb_fg><code>colorstring.rgb_fg(r: integer, g: integer, b: integer): {integer, integer, integer, integer, integer}</code></a>
</h3>
<p><p>The ansi escape for an arbitrary RGB foreground color</p></p>
<h2><a name=cyan.command>cyan.command</a>
</h2>
<p><p>The common interface for commands to implement</p></p>
<h3><a name=Command><code>type Command</code></a>
</h3>
<pre>record Command<br>   name: string<br>   description: string<br>   argparse: function(argparse.Command)<br>   script_hooks: {string}<br>   exec: CommandFn<br>end</pre>
<p><p>The interface</p></p>
<h3><a name=command.get><code>command.get(name: string): Command</code></a>
</h3>
<p><p>Get a command that was created with <code>command.new</code></p><p>Works whether or not <code>command.register_all</code> was called</p></p>
<h3><a name=command.merge_args_into_config><code>command.merge_args_into_config(cfg: config.Config, args: Args)</code></a>
</h3>
<p><p>Merge the relevant entries of the provided command arguments into the provided config table</p></p>
<h3><a name=command.new><code>command.new(cmd: Command)</code></a>
</h3>
<p><p>Create a new command</p><p>This is stored in an internal cache and will do nothing unless <code>command.register_all</code> is called afterwards</p></p>
<h3><a name=command.register_all><code>command.register_all(p: argparse.Parser)</code></a>
</h3>
<p><p>Install all commands created with <code>command.new</code> into the given parser</p></p>
<h2><a name=cyan.config>cyan.config</a>
</h2>
<p><p>Config loading API</p></p>
<h3><a name=Config><code>type Config</code></a>
</h3>
<pre>record Config<br>   loaded_from: fs.Path<br>   build_dir: string<br>   source_dir: string<br>   include: {string}<br>   exclude: {string}<br>   global_env_def: string<br>   include_dir: {string}<br>   module_name: string<br>   scripts: {string:{string:string|{string}}}<br>   gen_compat: tl.CompatMode<br>   gen_target: tl.TargetMode<br>   disable_warnings: {tl.WarningKind}<br>   warning_error: {tl.WarningKind}<br>   externals: {string:any}<br>end</pre>
<p><p>The config data</p></p>
<h3><a name=config.find><code>config.find(): fs.Path</code></a>
</h3>
<p><p>Find <code>config.filename</code> in the current or parent directories</p></p>
<h3><a name=config.is_config><code>config.is_config(c: any): Config, {string}, {string}</code></a>
</h3>
<p><p>Check if <code>c</code> conforms to the <code>Config</code> type and return any errors and warnings generated from checking</p></p>
<h3><a name=config.load><code>config.load(): Config, {string}, {string}</code></a>
</h3>
<p><p>Try to load <code>tlconfig.lua</code> in the current directory</p></p>
<h2><a name=cyan.fs.path>cyan.fs.path</a>
</h2>
<p><p>Object oriented lexical path management</p></p>
<h3><a name=Path.eq><code>Path.eq(a: Path | string, b: Path | string, use_os_sep: boolean): boolean</code></a>
</h3>
<p><p>Check if two paths are equal</p><p>This function is used for the __eq metamethod with use_os_sep as false</p></p>
<h3><a name=Path:ancestors><code>Path:ancestors(): function(): Path</code></a>
</h3>
<p><p>Iterate over the leading folders in a path</p><p>ex: <code>path.new(<code>"foo/bar/baz/bat"</code>):ancestors()</code> will construct <code>Path</code> objects from <code>"foo"</code>, <code>"foo/bar"</code>, <code>"foo/bar/baz"</code></p></p>
<h3><a name=Path:append><code>Path:append(other: string | Path)</code></a>
</h3>
<p><p>Mutate the given <code>Path</code> by appending another path to it</p><p>Traversals in the <code>other</code> path will be normalized</p><p></p><pre> local p = path.new <code>"foo/bar"</code><br> p:append <code>"../baz"</code><br> assert(p == path.new <code>"foo/baz"</code>)<br> </pre><p></p></p>
<h3><a name=Path:copy><code>Path:copy(): Path</code></a>
</h3>
<p><p>Create a copy of the given path</p></p>
<h3><a name=Path:exists><code>Path:exists(): boolean</code></a>
</h3>
<p><p>Check if the path exists</p></p>
<h3><a name=Path:is_absolute><code>Path:is_absolute(): boolean</code></a>
</h3>
<p><p>Returns whether the path is absolute</p><p>On windows, checks for paths like <code>"C:\..."</code>, elsewhere looks for <code>"/..."</code></p></p>
<h3><a name=Path:is_directory><code>Path:is_directory(): boolean</code></a>
</h3>
<p><p>Get whether the <code>"mode"</code> attribute of the given path is set to <code>"directory"</code></p></p>
<h3><a name=Path:is_file><code>Path:is_file(): boolean</code></a>
</h3>
<p><p>Get whether the <code>"mode"</code> attribute of the given path is set to <code>"file"</code></p></p>
<h3><a name=Path:is_in><code>Path:is_in(dirname: string | Path, use_os_sep: boolean): boolean</code></a>
</h3>
<p><p>returns true if the path is inside the given directory</p><p>If relative and absolute paths are mixed, the relative path is assumed to be in the current working directory (as determined by <code>lfs.currentdir()</code>)</p><p>If dirname is a <code>string</code>, a path will be constructed using <code>path.new</code> with <code>use_os_sep</code></p></p>
<h3><a name=Path:match><code>Path:match(patt: string): boolean</code></a>
</h3>
<p><p>See if the given path matches the pattern</p><p>Path separators in patterns are always represented with <code>'/'</code>.</p><p><code>*</code> characters represent any number of non-path-separator characters</p><p><code>**/</code> represent any number of directories</p></p>
<h3><a name=Path:match_any><code>Path:match_any(patts: {string}): integer, string</code></a>
</h3>
<p><p>See if the given path matches any of the given patterns</p></p>
<h3><a name=Path:mk_parent_dirs><code>Path:mk_parent_dirs(): boolean, string</code></a>
</h3>
<p><p>Attempt to create the leading directories of a given path</p></p>
<h3><a name=Path:mkdir><code>Path:mkdir(): boolean, string</code></a>
</h3>
<p><p>Attempt to create a directory at the given path, creating the parent directories if needed. Can be seen as an equivalent to <code>mkdir -p</code></p></p>
<h3><a name=Path:mod_time><code>Path:mod_time(): integer</code></a>
</h3>
<p><p>Get the <code>"modification"</code> attribute of a file</p></p>
<h3><a name=Path:normalize><code>Path:normalize()</code></a>
</h3>
<p><p>Modify path in place to remove any traversals that it can</p><p></p><pre> local p = path.new <code>"foo/bar/../baz"</code><br> p:normalize()<br> assert(p == path.new <code>"foo/baz"</code>)<br> </pre><p></p><p>if a traversal can't be removed it will remain </p><pre> local p = path.new <code>"../baz"</code><br> p:normalize()<br> assert(p == path.new <code>"../baz"</code>)<br> </pre><p></p></p>
<h3><a name=Path:prepend><code>Path:prepend(other: string | Path)</code></a>
</h3>
<p><p>Mutate the given <code>Path</code> by prepending another path to it</p></p>
<h3><a name=Path:relative_to><code>Path:relative_to(other: Path): Path</code></a>
</h3>
<p><p>Expresses a path in terms of another path. If any relative paths are given, they are treated as though they are in the current directory</p><p>for example: <code>path.new(<code>"/foo/bar/baz"</code>):relative_to(path.new(<code>"/foo/bat"</code>)) == path.new <code>"../bar/baz"</code></code></p></p>
<h3><a name=Path:remove_leading><code>Path:remove_leading(p: string | Path)</code></a>
</h3>
<p><p>Mutate the given path by removing the leading parts from the given path</p><p>Will error if you attempt to mix absolute and non-absolute paths</p></p>
<h3><a name=Path:to_absolute><code>Path:to_absolute()</code></a>
</h3>
<p><p>Modify a path in place to become an absolute path</p><p>When the path is already absolute, does nothing</p><p>Otherwise, prepends the current directory</p></p>
<h3><a name=Path:to_real_path><code>Path:to_real_path(): string</code></a>
</h3>
<p><p>Convert a <code>Path</code> to a string describing a real path</p></p>
<h3><a name=Path:tostring><code>Path:tostring(): string</code></a>
</h3>
<p><p>Convert a path to a string. Always uses <code>'/'</code> as a path separator. Intended for displaying purposes. For an actual path in the filesystem, use <code>Path:to_real_path()</code></p><p>Used for the __tostring metamethod</p></p>
<h3><a name=Path><code>type Path</code></a>
</h3>
<pre>record Path<br>   {string}<br><br>   metamethod __concat: function(Path | string, Path | string): Path<br>   metamethod __eq: function(Path | string, Path | string): boolean<br>end</pre>
<p><p>The main path object. Basically just an array of strings with some methods and metamethods to interact with other paths</p></p>
<h3><a name=path.ensure><code>path.ensure(s: string | Path, use_os_sep: boolean): Path</code></a>
</h3>
<p><p>Ensures <code>s</code> is a Path.</p><p>If s is a string, parse it into a path otherwise return s unmodified</p></p>
<h3><a name=path.new><code>path.new(s: string, use_os_sep: boolean): Path</code></a>
</h3>
<p><p>The <code>Path</code> constructor</p><p>By default uses <code>'/'</code> as a path separator</p></p>
<h2><a name=cyan.fs>cyan.fs</a>
</h2>
<p><p>Filesystem and path management</p></p>
<h3><a name=fs.chdir><code>fs.chdir(p: string | Path): boolean, string</code></a>
</h3>
<p><p>Change the current directory to <code>p</code></p></p>
<h3><a name=fs.copy><code>fs.copy(source: string | Path, dest: string | Path): boolean, string</code></a>
</h3>
<p><p>Copy a file</p><p>uses <code>fs.read</code> internally to get and cache the contents of <code>source</code></p></p>
<h3><a name=fs.cwd><code>fs.cwd(): Path</code></a>
</h3>
<p><p>Get the current working directory as an <code>fs.Path</code></p></p>
<h3><a name=fs.dir><code>fs.dir(dir: string | Path, include_dotfiles: boolean): function(): Path</code></a>
</h3>
<p><p>Iterate over the given directory, returning <code>fs.Path</code> objects</p><p>By default, will not include paths that start with <code>'.'</code></p></p>
<h3><a name=fs.extension_split><code>fs.extension_split(p: Path | string, ndots: integer): string, string</code></a>
</h3>
<p><p>Split a path on its extension. Forces the extension to be lowercase.</p><p>the <code>ndots</code> argument lets you specify the upper limit of how many dots the extension can have</p><p>ex: </p><pre> fs.extension_split(<code>"foo.d.tl"</code>) => <code>"foo.d"</code>, <code>".tl"</code><br> fs.extension_split(<code>"foo.d.tl"</code>, 2) => <code>"foo"</code>, <code>".d.tl"</code><br> fs.extension_split(<code>"foo.D.TL"</code>, 2) => <code>"foo"</code>, <code>".d.tl"</code><br> </pre><p></p></p>
<h3><a name=fs.get_line><code>fs.get_line(p: string, n: integer): string, string</code></a>
</h3>
<p><p>Gets line <code>n</code> of a file.</p><p>if the file is less than <code>n</code> lines, returns <code>nil</code></p><p>if there was an error opening the file, returns <code>nil</code>, err</p><p>Uses <code>fs.read()</code> internally, which caches reads</p></p>
<h3><a name=fs.path_concat><code>fs.path_concat(a: string, b: string): string</code></a>
</h3>
<p><p>Concatenate two strings using the os path separator</p></p>
<h3><a name=fs.read><code>fs.read(p: string): string, string</code></a>
</h3>
<p><p>Open a file, read it, close the file, return the contents or <code>nil</code> and an error if it couldn't be opened</p><p>Additionally caches results so multiple locations can read the same file for minimal cost. There is currently no way to clear out this cache.</p></p>
<h3><a name=fs.scan_dir><code>fs.scan_dir(dir: string | Path, include: {string}, exclude: {string}): function(): Path</code></a>
</h3>
<p><p>Recursively iterate over the files in a directory, following the provided <code>include</code> and <code>exclude</code> patterns</p><p>For information on path patterns, see the <code>Path:match()</code> method</p></p>
<h3><a name=fs.search_parent_dirs><code>fs.search_parent_dirs(start_path: string | Path, fname: string): Path</code></a>
</h3>
<p><p>Search for a file in the parent directories of the given path. Returns the path of the file found.</p><p>e.g. if <code>file.txt</code> is in <code>/foo/bar</code>, then <code>fs.search_parent_dirs(<code>"/foo/bar/baz"</code>, <code>"file.txt"</code>) == path.new <code>"/foo/bar/file.txt"</code></code></p></p>
<h2><a name=cyan.graph>cyan.graph</a>
</h2>
<p><p>A utility for building directed acyclic graphs of Teal source files</p><p>This is the main driver behind the <code>build</code> command</p></p>
<h3><a name=Dag:find><code>Dag:find(fstr: string | fs.Path): Node</code></a>
</h3>
<p><p>Find a node in the graph with the given path name</p></p>
<h3><a name=Dag:insert_file><code>Dag:insert_file(fstr: string | fs.Path, in_dir: string | fs.Path): boolean, {string}</code></a>
</h3>
<p><p>Inserts a file and its dependencies into a graph</p><p>Ignores absolute paths and non <code>.tl</code> or <code>.lua</code> files</p><p>If in_dir is provided, dependencies of the given file will not be added to the graph unless they are inside of the given dir</p><p>Returns <code>false</code> if inserting the file introduced a circular dependency along with a list of the filenames in the cycle</p></p>
<h3><a name=Dag:mark_each><code>Dag:mark_each(predicate: function(fs.Path): boolean)</code></a>
</h3>
<p><p>For each node in the graph, if <code>predicate</code> returns true for that input path, the node is marked for compilation, and that node's children are marked for type checking</p></p>
<h3><a name=Dag:marked_nodes><code>Dag:marked_nodes(m: Node.Mark): function(): Node</code></a>
</h3>
<p><p>Iterate over every node with the given mark <code>m</code>. Iterates in order of most dependents to least</p></p>
<h3><a name=Dag:nodes><code>Dag:nodes(): function(): Node</code></a>
</h3>
<p><p>Iterate over nodes in order of dependents</p><p>If two nodes have the same number of dependent nodes, the order of iteration between those two nodes is not guaranteed</p></p>
<h3><a name=Dag><code>type Dag</code></a>
</h3>
<pre>record Dag<br>   <details><summary class="private-field-comment">-- private fields</summary><br>   _nodes_by_filename: {string:Node}</details><br>end</pre>
<p><p>The graph object</p></p>
<h3><a name=Node><code>type Node</code></a>
</h3>
<pre>record Node<br>   input: fs.Path<br>   output: fs.Path<br>   modules: {string:fs.Path}<br>   mark: Mark<br>   dependents: {Node:boolean}<br>end</pre>
<p><p>The nodes that are stored in the graph</p></p>
<h3><a name=graph.empty><code>graph.empty(): Dag</code></a>
</h3>
<p><p>Initializes an empty graph</p></p>
<h3><a name=graph.scan_dir><code>graph.scan_dir(dir: string | fs.Path, include: {string}, exclude: {string}): Dag, {string}</code></a>
</h3>
<p><p>Recursively scan a directory (using <code>fs.scan_dir</code>) and build up a graph, respecting the given <code>include</code> and <code>exclude</code> patterns</p><p>Returns <code>nil</code> if a circular dependency was found, along with a list of the filenames in the cycle</p></p>
<h2><a name=cyan.log>cyan.log</a>
</h2>
<p><p>Console logging utils, not to be confused with log files</p><p>Each logger object has the same <code>__call</code> signature of <code>function(...: any)</code>, and by default the following are provided:</p><p></p><table> <tr><th> Name     </th><th> Stream </th><th> Description</th></tr> <tr><td>       <code>info</code>   </td><td> stdout </td><td> General info, should be seen as the default, silenced by --quiet</td></tr> <tr><td>       <code>extra</code>  </td><td> stdout </td><td> Extra info that isn&apos;t strictly necessary, enabled via -v extra, silenced by --quiet</td></tr> <tr><td>       <code>warn</code>   </td><td> stderr </td><td> Used to display warnings, silenced by --quiet</td></tr> <tr><td>       <code>err</code>    </td><td> stderr </td><td> Used to display errors</td></tr> <tr><td>       <code>debug</code>  </td><td> stderr </td><td> Used for debugging, uses the inspect module (if it is found) to print its arguments, enabled by -v debug</td></tr> </table><p></p><p>You may notice that these are nicely padded and after the first line the prefix is replaced by a <code>'...'</code>. Another function is provided, <code>create_logger</code>,</p><p></p><pre> create_logger: function(<br>    stream: FILE,<br>    verbosity_threshold: Verbosity,<br>    prefix: string | ColorString,<br>    cont: string | ColorString,<br>    inspector: function(any): string<br> ): Logger<br> </pre><p> to automatically generate formatted output. <code>cont</code> defaults to <code><code>"..."</code></code> and <code>inspector</code> defaults to <code>tostring</code>. Prefixes will be padded to 10 characters wide by default, so your logging may look off from the default if your prefix is longer.</p><p>Additionally, loggers will try to detect whether or not to display colors. This is only handled with the <code>ColorString</code> type to avoid the many pitfalls of trying to parse ANSI escape sequences. If a regular string contains any escape sequences or an inspector produces them (outside of a <code>ColorString</code>) it will not be handled.</p></p>
<h3><a name=Logger:cont><code>Logger:cont(...: any)</code></a>
</h3>
<p><p>Log only using the continuation prefix.</p></p>
<h3><a name=Logger:cont_nonl><code>Logger:cont_nonl(...: any)</code></a>
</h3>
<p><p>Log only using the continuation prefix, but don't put a newline at the end.</p></p>
<h3><a name=Logger:format><code>Logger:format(fmt: string, ...: any)</code></a>
</h3>
<p><p>Call <code>string.format</code> with the given arguments and log that.</p></p>
<h3><a name=Logger:format_nonl><code>Logger:format_nonl(fmt: string, ...: any)</code></a>
</h3>
<p><p>Call <code>string.format</code> with the given arguments and log that, without a new line.</p></p>
<h3><a name=Logger:nonl><code>Logger:nonl(...: any)</code></a>
</h3>
<p><p>Same as calling the logger, but don't put a newline at the end</p></p>
<h3><a name=Logger:should_log><code>Logger:should_log(): boolean</code></a>
</h3>
<p><p>Returns whether the current verbosity is less than or equal to this loggers verbosity threshold.</p></p>
<h3><a name=Logger><code>type Logger</code></a>
</h3>
<pre>record Logger<br>   stream: FILE<br>   verbosity_threshold: Verbosity<br>   prefix: string | cs.ColorString<br>   continuation: string | cs.ColorString<br>   inspector: function(any): string<br><br>   metamethod __call: function(...: any)<br>end</pre>
<p><p>The data needed for a logger to do its job.</p></p>
<h3><a name=Verbosity><code>type Verbosity</code></a>
</h3>
<pre>enum Verbosity<br>   "quiet"<br>   "normal"<br>   "extra"<br>   "debug"<br>end </pre>
<p><p>The thresholds for loggers to actually write their output</p></p>
<h3><a name=create_logger><code>create_logger(
   stream: FILE,
   verbosity_threshold: Verbosity,
   prefix: string | cs.ColorString,
   cont: string | cs.ColorString,
   inspector: function(any): string
): Logger</code></a>
</h3>
<p><p>Creates a Logger as described above</p></p>
<h3><a name=log.set_prefix_padding><code>log.set_prefix_padding(padding: integer)</code></a>
</h3>
<p><p>Globally set the padding of the prefixes of loggers.</p></p>
<h3><a name=log.set_verbosity><code>log.set_verbosity(level: Verbosity)</code></a>
</h3>
<p><p>Globally set the verbosity of the logging module.</p></p>
<h2><a name=cyan.meta>cyan.meta</a>
</h2>
<p><p>Meta information about Cyan itself</p></p>
<h2><a name=cyan.sandbox>cyan.sandbox</a>
</h2>
<p><p>Super simplistic sandboxing In the future maybe could be integrated with some very simple debugging utilities for now, we just offer the convenience of exiting gracefully if someone puts <code>while true do end</code> in their config for some reason</p></p>
<h2><a name=cyan.script>cyan.script</a>
</h2>
<p><p>The script loading api</p></p>
<h3><a name=script.disable><code>script.disable()</code></a>
</h3>
<p><p>Make everything in this library a no-op, there is currently no way to re-enable this</p></p>
<h3><a name=script.emit_hook><code>script.emit_hook(name: string, ...: any): boolean, string</code></a>
</h3>
<p><p>Iterates through each loaded script and runs any with the given hook, logging each script that it ran, and stopping early if any error</p></p>
<h3><a name=script.emitter><code>script.emitter(name: string, ...: any): function(): fs.Path, boolean, string</code></a>
</h3>
<p><p>Emit a hook to load and run all registered scripts that run on the given hook.</p><p>This function will assert that <code>ensure_loaded_for_command</code> was called before.</p><p>Returns an iterator that will run the next script when called and returns the path to the script, whether the script was loaded and ran with no errors, and an error message if it didn't</p></p>
<h3><a name=script.ensure_loaded_for_command><code>script.ensure_loaded_for_command(name: string): boolean, string | tl.Result</code></a>
</h3>
<p><p>Attempts to load each script that the given command may need</p></p>
<h3><a name=script.register><code>script.register(path: string, command_name: string, hooks: string | {string})</code></a>
</h3>
<p><p>Registers a file path as a lua/teal script to execute for the given hook(s) when <code>script.emit_hook</code> is called</p><p>This is called by the cli driver to register the scripts found in the config file with the relevant hooks</p><p>Note: this function does not attempt to actually load the file. Scripts are loaded all at once via <code>ensure_loaded_for_command</code></p></p>
<h2><a name=cyan.tlcommon>cyan.tlcommon</a>
</h2>
<p><p>Common things needed by most commands in addition to wrappers around the tl api, since it isn't super stable</p></p>
<h3><a name=ParseResult><code>type ParseResult</code></a>
</h3>
<pre>record ParseResult<br>   tks: {Token}<br>   ast: Node<br>   reqs: {string}<br>   errs: {tl.Error}<br>end</pre>
<p><p>The result from parsing source code including the tokens, ast, calls to require, and errors</p></p>
<h3><a name=common.init_env_from_config><code>common.init_env_from_config(cfg: config.Config): tl.Env, string</code></a>
</h3>
<p><p>Initialize a strict Teal environment, using the relevant entries of the config to modify that environment</p><p>may return <code>nil</code> and an error message if something could not be applied to the environment</p></p>
<h3><a name=common.init_teal_env><code>common.init_teal_env(gen_compat: boolean | tl.CompatMode, gen_target: tl.TargetMode, env_def: string): tl.Env, string</code></a>
</h3>
<p><p>Initialize a strict Teal environment</p></p>
<h3><a name=common.lex_file><code>common.lex_file(path: string): {Token}, {Token}, string</code></a>
</h3>
<p><p>reads a file, calls <code>tl.lex</code> on its contents, caches and returns the results</p></p>
<h3><a name=common.make_error_header><code>common.make_error_header(file: string, num_errors: integer, category: string): cs.ColorString</code></a>
</h3>
<p><p>Creates a nicely colored header to log errors</p><p>For example <code>make_error_header(<code>"foo.tl"</code>, 10, <code>"foo error"</code>)</code> would produce something like <code>10 foo errors in foo.tl</code> with <code>10</code> and <code>foo.tl</code> highlighted</p></p>
<h3><a name=common.parse_file><code>common.parse_file(path: string): ParseResult, string</code></a>
</h3>
<p><p>calls <code>lex_file</code>, parses the token stream, caches and returns the results</p></p>
<h3><a name=common.prepend_to_lua_path><code>common.prepend_to_lua_path(path_str: string)</code></a>
</h3>
<p><p>Prepend the given string to package.path and package.cpath.</p><p>Correctly adds ?.lua and ?/init.lua to the path</p></p>
<h3><a name=common.report_config_errors><code>common.report_config_errors(errs: {string}, warnings: {string}): boolean</code></a>
</h3>
<p><p>use <code>log.warn</code> and <code>log.err</code> to report errors and warnings from <code>config.load</code></p></p>
<h3><a name=common.report_env_results><code>common.report_env_results(env: tl.Env, cfg: config.Config): boolean</code></a>
</h3>
<p><p>Report all errors from a tl.Env</p><p>Returns false when errors were reported</p></p>
<h3><a name=common.report_errors><code>common.report_errors(logger: log.Logger, errs: {tl.Error}, file: string, category: string)</code></a>
</h3>
<p><p>Logs an array of errors with nice colors and a header generated by <code>make_error_header</code></p></p>
<h3><a name=common.report_result><code>common.report_result(r: tl.Result, c: config.Config): boolean</code></a>
</h3>
<p><p>Logs all the syntax errors, warnings, type errors, etc. from a <code>tl.Result</code> with proper colors</p><p>Returns false if there were any errors. This includs warnings that were promoted to errors and doesn't include warnings that were not promoted to errors.</p></p>
<h3><a name=common.result_has_errors><code>common.result_has_errors(r: tl.Result, c: config.Config): boolean</code></a>
</h3>
<p><p>Returns whether or not the result has errors. Doesn't print/log anything</p></p>
<h3><a name=common.search_module><code>common.search_module(name: string, search_dtl: boolean): fs.Path</code></a>
</h3>
<p><p>A wrapper around <code>tl.search_module</code> but, returns an <code>fs.Path</code> and will cache results</p></p>
<h3><a name=common.type_check_ast><code>common.type_check_ast(ast: Node, opts: tl.TypeCheckOptions): tl.Result</code></a>
</h3>
<p><p>Just type checks an ast</p></p>
<h2><a name=cyan.util>cyan.util</a>
</h2>
<p><p>Basically some extensions of the std lib. Currently these lean towards a more functional style</p><p>This is split into two main modules, <code>str</code> and <code>tab</code>. For string and table utilities respectively.</p></p>
<h3><a name=str.esc><code>str.esc(s: string, sub: string | function(string): string | {string:string}): string, integer</code></a>
</h3>
<p><p>escape any special characters in a string</p><p>use <code>sub</code> to control how the characters are substituted, by default a special character <code>x</code> will be replaced with <code>%x</code></p><p>returns the new string and the number of characters replaced</p></p>
<h3><a name=str.pad_left><code>str.pad_left(s: string, n: integer): string</code></a>
</h3>
<p><p>Prefix <code>s</code> with spaces so the resulting string is at least <code>n</code> characters long</p></p>
<h3><a name=str.split><code>str.split(s: string, del: string, no_patt: boolean): function(): string</code></a>
</h3>
<p><p>Split a string by <code>del</code>, returning the substring that was matched</p><p>Will error if the delimiter matches the empty string</p></p>
<h3><a name=str.split_find><code>str.split_find(s: string, del: string, no_patt: boolean): function(): integer, integer</code></a>
</h3>
<p><p>Split a string by <code>del</code>, returning the indexes of the match</p><p>Will error if the delimiter matches the empty string</p></p>
<h3><a name=tab.contains><code>tab.contains&lt;Value&gt;(t: {Value}, val: Value): boolean</code></a>
</h3>
<p><p>Report if an array contains an element (as determined by the <code>==</code> operator)</p></p>
<h3><a name=tab.filter><code>tab.filter&lt;Value&gt;(t: {Value}, pred: function(Value): boolean): {Value}, {Value}</code></a>
</h3>
<p><p>Create two new lists from <code>t</code>: the values that return <code>true</code> from <code>pred</code> and the values that return false</p></p>
<h3><a name=tab.from><code>tab.from&lt;Value&gt;(fn: function(...: any): (Value), ...: any): {Value}</code></a>
</h3>
<p><p>Collect all the values of an iterator in a list</p></p>
<h3><a name=tab.intersperse><code>tab.intersperse&lt;Value&gt;(t: {Value}, val: Value): {Value}</code></a>
</h3>
<p><p>produce a new list by inserting <code>val</code> after each element</p></p>
<h3><a name=tab.ivalues><code>tab.ivalues&lt;Value&gt;(t: {any:Value}): function(): Value</code></a>
</h3>
<p><p>Iterate over the integer indexed values of a map</p></p>
<h3><a name=tab.keys><code>tab.keys&lt;Key&gt;(t: {Key:any}): function(): Key</code></a>
</h3>
<p><p>Iterate over the keys of a map</p></p>
<h3><a name=tab.map><code>tab.map&lt;Key, Value, MappedValue&gt;(t: {Key:Value}, fn: function(Value): MappedValue): {Key:MappedValue}</code></a>
</h3>
<p><p>Create a new map from <code>t</code> by passing each value through <code>fn</code></p></p>
<h3><a name=tab.map_ipairs><code>tab.map_ipairs&lt;Value, MappedValue&gt;(t: {Value}, fn: function(Value): MappedValue): function(): integer, MappedValue</code></a>
</h3>
<p><p>iterate over a list like ipairs does, but filter the values through <code>fn</code></p></p>
<h3><a name=tab.merge_list><code>tab.merge_list&lt;Value&gt;(a: {Value}, b: {Value}): {Value}</code></a>
</h3>
<p><p>Create a new list by shallow copying the contents of <code>a</code> and <code>b</code></p></p>
<h3><a name=tab.set><code>tab.set&lt;Value&gt;(lst: {Value}): {Value:boolean}</code></a>
</h3>
<p><p>Create a Set from a list</p></p>
<h3><a name=tab.sort_in_place><code>tab.sort_in_place&lt;Value&gt;(t: {Value}, fn: function(Value, Value): boolean): {Value}</code></a>
</h3>
<p><p>Sort a table (in place) and return that table</p></p>
<h3><a name=tab.values><code>tab.values&lt;Key, Value&gt;(t: {Key:Value}): function(): Value</code></a>
</h3>
<p><p>Iterate over the values of a map</p></p>

</body>
</html>
