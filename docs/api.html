<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8"/>
<style>
html {
   background-color: #16191a;
}

body {
   background-color: #181a1b;
   margin: auto;
   max-width: 70em;
   width: 90%;
   padding: 32px;
   font-family: Helvetica, Arial, sans-serif;
   color: #e8e6e3;
}

a {
   text-decoration: none;
   color: #3391ff;
}

h2 {
   color: #117dee;
}
</style>
<body>
<h1>
Api Documentation</h1>
<p>
This documentation is autogenerated and may be incomplete</p>
<br><br><h1>
cyan.colorstring</h1>
<p>
Some wrappers/conveniences around working with ansi escape codes  For example getting the length of a string that contains escape codes shouldnt include them<br><br></p>
<h2>
ColorString:surround(col: {number})</h2>
<p>
surrounds a string with a color</p>
<h2>
ColorString:tostring(): string</h2>
<p>
Converts a <code>Colorstring</code> to a regular string with the correct ANSI escapes</p>
<h2>
colorstring.highlight(hl: {number}, str: string): ColorString</h2>
<p>
Create a <code>Colorstring</code> by surrounding a string with the given ANSI color and an ANSI reset</p>
<h2>
colorstring.new(...: string | {number}): ColorString</h2>
<p>
The <code>Colorstring</code> constructor</p>
<h2>
colorstring.rgb_bg(r: number, g: number, b: number): {number, number, number, number, number}</h2>
<p>
The ansi escape for an arbitrary RGB background color</p>
<h2>
colorstring.rgb_fg(r: number, g: number, b: number): {number, number, number, number, number}</h2>
<p>
The ansi escape for an arbitrary RGB foreground color</p>
<pre>
record ColorString<br>   metamethod __len: function(ColorString): number<br>   metamethod __concat: function(ColorString | string, ColorString | string): ColorString<br>   content: {string | {number}}<br>   len: function(ColorString): number<br>   tostring: function(ColorString): string<br>end</pre>
<br><p>
The main object that this library consumes and produces. It basically implements the  'string' interface and can be used wherever a string is. Colors are described as arrays of numbers that directly correspond to ANSI escape sequences</p>
<h1>
cyan.command</h1>
<p>
The common interface for commands to implement<br><br></p>
<h2>
command.get(name: string): Command</h2>
<p>
Get a command that was created with <code>command.new</code> Works whether or not <code>command.register_all</code> was called</p>
<h2>
command.merge_args_into_config(cfg: config.Config, args: Args)</h2>
<p>
Merge the relevant entries of the provided command arguments into the provided config table</p>
<h2>
command.new(cmd: Command)</h2>
<p>
Create a new command This is stored in an internal cache and will do nothing unless  <code>command.register_all</code> is called afterwards</p>
<h2>
command.register_all(p: argparse.Parser)</h2>
<p>
Install all commands created with <code>command.new</code> into the given parser</p>
<pre>
record Command<br>   <br>   name: string<br>   description: string<br>   argparse: function(argparse.Command)<br>   script_hooks: {string}<br>   exec: CommandFn<br>end</pre>
<br><p>
The interface</p>
<h1>
cyan.config</h1>
<p>
Config loading API<br><br></p>
<h2>
config.find(): fs.Path</h2>
<p>
Find <code>config.filename</code> in the current or parent directories</p>
<h2>
config.is_config(c: any): Config, {string}, {string}</h2>
<p>
Check if <code>c</code> conforms to the <code>Config</code> type and return any errors and warnings generated from checking</p>
<h2>
config.load(): Config, {string}, {string}</h2>
<p>
Try to load <code>tlconfig.lua</code> in the current directory</p>
<pre>
record Config<br>   <br>   loaded_from: fs.Path<br>   build_dir: string<br>   source_dir: string<br>   include: {string}<br>   exclude: {string}<br>   global_env_def: string<br>   include_dir: {string}<br>   module_name: string<br>   scripts: {string:{string}}<br>   gen_compat: tl.CompatMode<br>   gen_target: tl.TargetMode<br>   disable_warnings: {tl.WarningKind}<br>   warning_error: {tl.WarningKind}<br>   externals: {string:any}<br>end</pre>
<br><p>
The config data</p>
<h1>
cyan.fs.path</h1>
<p>
Object oriented path management<br><br></p>
<h2>
Path.eq(a: Path | string, b: Path | string, use_os_sep: boolean): boolean</h2>
<p>
Check if two paths are equal This function is used for the __eq metamethod with use_os_sep as false</p>
<h2>
Path:ancestors(): function(): Path</h2>
<p>
Iterate over the leading folders in a path ex: <code>path.new("foo/bar/baz/bat"):ancestors()</code> will construct <code>Path</code> objects from "foo", "foo/bar", "foo/bar/baz"</p>
<h2>
Path:append(other: string | Path)</h2>
<p>
Mutate the given <code>Path</code> by appending another path to it</p>
<h2>
Path:copy(): Path</h2>
<p>
Create a copy of the given path</p>
<h2>
Path:exists(): boolean</h2>
<p>
Check if the path exists</p>
<h2>
Path:is_absolute(): boolean</h2>
<p>
Returns whether the path is absolute On windows, checks for paths like "C:\...", elsewhere looks for "/..."</p>
<h2>
Path:is_directory(): boolean</h2>
<p>
Get whether the "mode" attribute of the given path is set to "directory"</p>
<h2>
Path:is_file(): boolean</h2>
<p>
Get whether the "mode" attribute of the given path is set to "file"</p>
<h2>
Path:is_in(dirname: string | Path): boolean</h2>
<p>
returns true if the path is inside the given directory If relative and absolute paths are mixed, the relative path is assumed to  be in the current working directory (as determined by <code>lfs.currentdir()</code>)</p>
<h2>
Path:match(patt: string): boolean</h2>
<p>
See if the given path matches the pattern Path separators in patterns are always represented with '/'. <code>*</code> characters represent any number of non-path-separator characters <code>**/</code> represent any number of directories</p>
<h2>
Path:match_any(patts: {string}): integer, string</h2>
<p>
See if the given path matches any of the given patterns</p>
<h2>
Path:mk_parent_dirs(): boolean, string</h2>
<p>
Attempt to create the leading directories of a given path</p>
<h2>
Path:mkdir(): boolean, string</h2>
<p>
Attempt to create a directory at the given path, creating the parent directories  if needed. Can be seen as an equivalent to <code>mkdir -p</code></p>
<h2>
Path:mod_time(): integer</h2>
<p>
Get the "modification" attribute of a file</p>
<h2>
Path:prepend(other: string | Path)</h2>
<p>
Mutate the given <code>Path</code> by prepending another path to it</p>
<h2>
Path:relative_to(other: Path): string</h2>
<p>
Expresses a path in terms of another path.  If any relative paths are given, they are treated as though they are in the current directory Returns an actual path since path objects cannot contain '..' for example: <code>path.new("/foo/bar/baz"):relative_to(path.new("/foo/bat")) == "../bar/baz"</code></p>
<h2>
Path:remove_leading(p: string | Path)</h2>
<p>
Mutate the given path by removing the leading parts from the given path Will error if you attempt to mix absolute and non-absolute paths</p>
<h2>
Path:to_real_path(): string</h2>
<p>
Convert a <code>Path</code> to a string describing a real path</p>
<h2>
Path:tostring(): string</h2>
<p>
Convert a path to a string. Always uses '/' as a path separator. Intended for displaying purposes. For an actual path in the filesystem, use <code>Path:to_real_path()</code> Used for the __tostring metamethod</p>
<h2>
path.ensure(s: string | Path): Path</h2>
<p>
Ensures <code>s</code> is a Path</p>
<h2>
path.new(s: string, use_os_sep: boolean): Path</h2>
<p>
The <code>Path</code> constructor By default uses '/' as a path separator</p>
<pre>
record Path<br>   metamethod __concat: function(Path | string, Path | string): Path<br>   metamethod __eq: function(Path | string, Path | string): boolean<br>   {string}<br>end</pre>
<br><p>
The main path object. Basically just an array of strings with some methods and metamethods to interact with other paths</p>
<h1>
cyan.fs</h1>
<p>
Search for a file in the parent directories of the given path. Returns the path of the file found. e.g. if <code>file.txt</code> is in <code>/foo/bar</code>  <code>fs.search_parent_dirs("/foo/bar/baz", "file.txt") == "/foo/bar/file.txt"</code><br><br></p>
<h2>
fs.chdir(p: string | Path): boolean, string</h2>
<p>
Change the current directory to <code>p</code></p>
<h2>
fs.cwd(): Path</h2>
<p>
Get the current working directory as an <code>fs.Path</code></p>
<h2>
fs.dir(dir: string | Path, include_dotfiles: boolean): function(): Path</h2>
<p>
Iterate over the given directory, returning <code>fs.Path</code> objects By default, will not include paths that start with '.'</p>
<h2>
fs.scan_dir(dir: string | Path, include: {string}, exclude: {string}): function(): Path</h2>
<p>
Recursively iterate over the files in a directory, following the provided <code>include</code> and <code>exclude</code> patterns</p>
<h1>
cyan.graph</h1>
<p>
A utility for building directed acyclic graphs of Teal source files This is the main driver behind the <code>build</code> command<br><br></p>
<h2>
Dag:find(fstr: string | fs.Path): Node</h2>
<p>
Find a node in the graph with the given path name</p>
<h2>
Dag:insert_file(fstr: string | fs.Path, in_dir: string | fs.Path)</h2>
<p>
Inserts a file and its dependencies into a graph Ignores absolute paths and non <code>.tl</code> files If in_dir is provided, dependencies of the given file will not be added to  the graph unless they are inside of the given dir</p>
<h2>
Dag:mark_each(predicate: function(fs.Path): boolean)</h2>
<p>
For each node in the graph, if <code>predicate</code> returns true for that input  path, the node is marked for compilation, and that node's children are marked  for type checking</p>
<h2>
Dag:marked_nodes(m: Node.Mark): function(): Node</h2>
<p>
Iterate over every node with the given mark <code>m</code>. Iterates in order of most dependents to least</p>
<h2>
Dag:nodes(): function(): Node</h2>
<p>
Iterate over nodes in order of dependents If two nodes have the same number of dependent nodes, the order of  iteration between those two nodes is not guaranteed</p>
<h2>
graph.empty(): Dag</h2>
<p>
Initializes an empty graph</p>
<h2>
graph.scan_dir(dir: string | fs.Path, include: {string}, exclude: {string}): Dag</h2>
<p>
Recursively scan a directory (using <code>fs.scan_dir</code>) and build up a graph,  respecting the given <code>include</code> and <code>exclude</code> patterns</p>
<pre>
record Dag<br>   <br>   <br>end</pre>
<br><p>
The graph object</p>
<h1>
cyan.log</h1>
<p>
Console logging utils, not to be confused with log files Each logging function has the same signature of <code>function(...: any)</code>, and  by default the following are provided:<table><tr><th> Name     </th><th> Stream </th><th> Description</th></tr><tr><td>        <code>info</code>   </td><td> stdout </td><td> General info, should be seen as the default, silenced by --quiet</td></tr><tr><td>        <code>warn</code>   </td><td> stderr </td><td> Used to display warnings, silenced by --quiet</td></tr><tr><td>        <code>err</code>    </td><td> stderr </td><td> Used to display errors</td></tr><tr><td>        <code>debug</code>  </td><td> stderr </td><td> Used for debugging, uses the inspect module (if it is found) to print its arguments</td></tr></table><br><br> You may notice that these are nicely padded and after the first line the prefix is replaced by a '...'  Another function is provided, <code>create_logger</code>, <pre>  create_logger: function(<br>     stream: FILE,<br>     prefix: string | ColorString,<br>     cont: string | ColorString,<br>     inspector: function(any): string<br>  ): function(...: any)<br>  </pre>  to automatically generate formatted output. <code>cont</code> defaults to <code>"..."</code> and  <code>inspector</code> defaults to <code>tostring</code>. Prefixes will be padded to 10 characters  wide, so your logging may look off from the default if your prefix is longer.<br><br></p>
<h2>
create_logger(
   stream: FILE,
   prefix: string | cs.ColorString,
   cont: string | cs.ColorString,
   inspector: function(any): string
): function(...: any)</h2>
<p>
Creates a logging function as described above</p>
<h1>
cyan.script</h1>
<p>
The script loading api<br><br></p>
<h2>
script.disable()</h2>
<p>
Make everything in this library a no-op, there is currently no way to re-enable this</p>
<h2>
script.emit_hook(name: string, ...: any): boolean, string</h2>
<p>
Iterates through each loaded script and runs any with the given hook,  logging each script that it ran, and stopping early if any error</p>
<h2>
script.emitter(name: string, ...: any): function(): fs.Path, boolean, string</h2>
<p>
Emit a hook to run all loaded scripts that run on the given hook. Returns  an iterator that will run the next script when called and returns the path to  the script, whether the script succeeded, and an error message if it didn't</p>
<h2>
script.load(path: string, flags: {string}): boolean, string</h2>
<p>
Loads a file as a lua/teal script and caches it with the given flags to be  run when <code>script.emit_hook</code> is called This is called by the cli driver to load the scripts found in the config  file with the relevant hooks</p>
<h1>
cyan.tlcommon</h1>
<p>
Common things needed by most commands in addition to  wrappers around the tl api, since it isn't super stable<br><br></p>
<h2>
common.init_env_from_config(cfg: config.Config): tl.Env, string</h2>
<p>
Initialize a strict Teal environment, using the relevant entries of the config to modify that environment may return <code>nil</code> and an error message if something could not be applied to the environment</p>
<h2>
common.init_teal_env(gen_compat: boolean | tl.CompatMode, gen_target: tl.TargetMode, env_def: string): tl.Env, string</h2>
<p>
Initialize a strict Teal environment</p>
<h2>
common.make_error_header(file: string, num_errors: number, category: string): string</h2>
<p>
Creates a nicely colored header to log errors For example <code>make_error_header("foo.tl", 10, "foo error")</code> would produce  something like <code>10 foo errors in foo.tl</code> with <code>10</code> and <code>foo.tl</code> highlighted</p>
<h2>
common.prepend_to_lua_path(path_str: string)</h2>
<p>
Prepend the given string to package.path and package.cpath. Correctly adds ?.lua and ?/init.lua to the path</p>
<h2>
common.report_config_errors(errs: {string}, warnings: {string}): boolean</h2>
<p>
use <code>log.warn</code> and <code>log.err</code> to report errors and warnings from <code>config.load</code></p>
<h2>
common.report_env_results(env: tl.Env, cfg: config.Config): boolean</h2>
<p>
Report all errors from a tl.Env Returns false when errors were reported</p>
<h2>
common.report_errors(logfn: function(...: any), errs: {tl.Error}, file: string, category: string)</h2>
<p>
Logs an array of errors with nice colors and a header generated by <code>make_error_header</code></p>
<h2>
common.report_result(r: tl.Result, c: config.Config): boolean</h2>
<p>
Logs all the syntax errors, warnings, type errors, etc. from a <code>tl.Result</code> with proper colors Returns if there were any warnings or unknowns. May return <code>true</code> even if some warnings were reported</p>
<h2>
common.result_has_errors(r: tl.Result, c: config.Config): boolean</h2>
<p>
Returns whether or not the result has errors. Doesn't print/log anything</p>
<h2>
common.search_module(name: string, search_dtl: boolean): fs.Path</h2>
<p>
A wrapper around <code>tl.search_module</code> but, returns an <code>fs.Path</code> and will cache results</p>
<h2>
common.type_check_ast(ast: Node, opts: tl.TypeCheckOptions): tl.Result</h2>
<p>
Just type checks an ast</p>
<pre>
record ParseResult<br>   <br>   tks: {Token}<br>   ast: Node<br>   reqs: {string}<br>   errs: {tl.Error}<br>end</pre>
<br><p>
The result from parsing source code including the tokens, ast, calls to require, and errors</p>
<h1>
cyan.util</h1>
<p>
Basically some extensions of the std lib  Currently these lean towards a more functional style<br><br></p>
<h2>
str.esc(s: string, sub: string | function(string): string | {string:string}): string, number</h2>
<p>
escape any special characters in a string use <code>sub</code> to control how the characters are substituted, by default a special character <code>x</code> will be replaced with <code>%x</code></p>
<h2>
str.pad_left(s: string, n: number): string</h2>
<p>
Prefix <code>s</code> with spaces so the resulting string is at least <code>n</code> characters long</p>
<h2>
str.split(s: string, del: string, no_patt: boolean): function(): string</h2>
<p>
Split a string by <code>del</code>, returning the substring that was matched Will error if the delimiter matches the empty string</p>
<h2>
str.split_find(s: string, del: string, no_patt: boolean): function(): number, number</h2>
<p>
Split a string by <code>del</code>, returning the indexes of the match Will error if the delimiter matches the empty string</p>
<h2>
tab.filter(t: {T}, pred: function(T): boolean): {T}, {T}</h2>
<p>
Create two new lists from <code>t</code>: the values that return <code>true</code> from <code>pred</code> and the values that return false</p>
<h2>
tab.from(fn: function(...: any): (T), ...: any): {T}</h2>
<p>
Collect all the values of an iterator in a list</p>
<h2>
tab.ivalues(t: {any:V}): function(): V</h2>
<p>
Iterate over the integer indexed values of a map</p>
<h2>
tab.keys(t: {K:any}): function(): K</h2>
<p>
Iterate over the keys of a map</p>
<h2>
tab.map(t: {K:V}, fn: function(V): T): {K:T}</h2>
<p>
Create a new map from <code>t</code> by passing each value through <code>fn</code></p>
<h2>
tab.map_ipairs(t: {T}, fn: function(T): K): function(): number, K</h2>
<p>
iterate over a list like ipairs does, but filter the values through <code>fn</code></p>
<h2>
tab.merge_list(a: {T}, b: {T}): {T}</h2>
<p>
Create a new list by shallow copying the contents of <code>a</code> and <code>b</code></p>
<h2>
tab.set(lst: {T}): {T:boolean}</h2>
<p>
Create a Set from a list</p>
<h2>
tab.sort(t: {T}, fn: function(T, T): boolean): {T}</h2>
<p>
Sort a table (in place) and return that table</p>
<h2>
tab.values(t: {K:V}): function(): V</h2>
<p>
Iterate over the values of a map</p>
</body>
</html>
